#!/bin/ksh
#
# SPDX-License-Identifier: CDDL-1.0
#
# {{{ CDDL HEADER
#
# This file and its contents are supplied under the terms of the
# Common Development and Distribution License ("CDDL"), version 1.0.
# You may only use this file in accordance with the terms of version
# 1.0 of the CDDL.
#
# A full copy of the text of the CDDL should have accompanied this
# source. A copy of the CDDL is also available via the Internet at
# http://www.illumos.org/license/CDDL.
#
# }}}
#
# Copyright 2024 Peter Tribble
#

#
# Create a zone
#
# Usage:
#  -6 set up link-local ipv6 addresses
#  -B blank boot
#  -c cpu allocation (vcpus for bhyve, limit for others)
#  -C enable cloud-init
#  -d directory to create [can be multiple]
#  -D dataset to delegate [will be created if it doesn't exist]
#  -f bhyve firmware (in /usr/share/bhyve/firmware)
#  -F create a flow with the given properties
#  -i IPv4 address [can be multiple, for shared-ip]
#  -I image file to install for alien, s10, bhyve, or lx zone
#  -k ssh public key, enables cloud-init
#  -K konfigurator arguments
#  -m ram allocation (size for bhyve, limit for others)
#  -n create this many zones, all the same
#  -o overlay for partial root [can be multiple, passed to install]
#  -O add overlay [can be multiple, passed to install]
#  -p package for partial root [can be multiple, passed to install]
#  -P add package [can be multiple, passed to install]
#  -R Ipv4 network to proxy, in CIDR notation
#  -s share directory r/o with the zone
#  -S share directory r/w with the zone
#  -t brand - sparse, whole, alien, appstack, s10, bhyve, or lx [default sparse]
#  -T template (implies sparse)
#  -U share user and their homedir with the zone
#  -v existing zvol for bhyve to use
#  -V size of new volume for bhyve (may be repeated)
#  -x IPv4 address [can be multiple, for exclusive-ip]
#  -z zone_name - zone name [required]
#
# FIXMES:
# add full IPv6
# add appstack overlays for sparse zones
#

ZAPLIBDIR="/usr/lib/zap"
ZFSBASE="/export/zonedata"
ZROOTBASE="/export/zones"
ZSDIR="/var/zap/zones"
ZBRAND=TRIBsparse
ZNAME=""
ZIP4=""
XIP4=""
RIP4=""
NRIP4=""
ORIP4=""
ZISOFILE=""
IMGFLAG="-i"
ZOVERLAY=""
ZADDOVERLAY=""
ZPACKAGE=""
ZADDPACKAGE=""
ZDIRS=""
ZDATASETS=""
ZSHARED=""
ZROSHARED=""
ZUSERS=""
ZTEMPLATE=""
ZTEMPLATEPATH=""
ZBLANK=""
NZONES=""
KARGS=""
DOIP6=""
NCMDLINE=""
SYSIDCFGFILE=""
FLOWPROPS=""
BHYVEVOL=""
BHYVEVOLSIZES=""
RAMSPEC=""
BHYVEPOOL="rpool"
BHYVEFW=BHYVE_RELEASE
CLOUDINIT=""
SSHKEYFILE=""
ISROUTER=""
CPUSPEC=""

#
# these associative arrays track the interface to address mapping
#
typeset -A ifipmap
typeset -A xifipmap

usage() {
    LXUSAGE=""
    S10USAGE=""
    BHYVEUSAGE=""
    VOLUSAGE=""
    MEMUSAGE=" [-m ram_size]"
    if [ -f /etc/zones/SUNWlx.xml ]; then
	LXUSAGE="|lx"
    fi
    if [ -f /etc/zones/SUNWsolaris10.xml ]; then
	S10USAGE="|s10"
    fi
    if [ -f /usr/lib/brand/bhyve/platform.xml ]; then
	BHYVEUSAGE="|bhyve"
	VOLUSAGE=" [-v volume | -V volsize]"
	MEMUSAGE=" [-m ram_size] [-f firmware]"
    fi
    echo "Usage: $0 -z zone_name [-t whole|sparse|alien${BHYVEUSAGE}${LXUSAGE}${S10USAGE}|router]"
    echo "  [-T template] [-I image_file] [-U user]"
    echo "  [-i ip_address] [-x ip_address] [-R ip_network/prefix] [-6]"
    echo "  [-o overlay] [-O overlay] [-p package] [-P package]"
    echo "  [-d extra_dir] [-s|-S shared_dir] [-D dataset]${VOLUSAGE}"
    echo "  [-B] [-n number_of_zones] [-F flow_props]${MEMUSAGE}"
    echo "  [-c cpu_spec] [-C] [-k sshkey_file]"
    #echo "  [-K action=arg[=arg...]]"
    exit 1
}

while getopts "6Bc:Cd:D:f:F:i:I:k:K:m:n:o:O:p:P:R:s:S:t:T:U:v:V:x:z:" opt; do
case $opt in
6)
	DOIP6="Y"
	NCMDLINE="${NCMDLINE} -6"
	;;
B)
	ZBLANK="Y"
	NCMDLINE="${NCMDLINE} -B"
	;;
c)
	CPUSPEC="$OPTARG"
	NCMDLINE="${NCMDLINE} -c $OPTARG"
	;;
C)
	CLOUDINIT="Y"
	NCMDLINE="${NCMDLINE} -C"
	;;
T)
	ZTEMPLATE="$OPTARG"
	;;
t)
	ZBRAND="$OPTARG"
	;;
z)
	ZNAME="$OPTARG"
	;;
i)
	ZIP4="${ZIP4} $OPTARG"
	;;
x)
	XIP4="${XIP4} $OPTARG"
	;;
R)
	RIP4="${RIP4} $OPTARG"
	;;
I)
	ZISOFILE="$OPTARG"
	NCMDLINE="${NCMDLINE} -I $OPTARG"
	;;
o)
	ZOVERLAY="${ZOVERLAY} $OPTARG"
	NCMDLINE="${NCMDLINE} -o $OPTARG"
	;;
O)
	ZADDOVERLAY="${ZADDOVERLAY} $OPTARG"
	NCMDLINE="${NCMDLINE} -O $OPTARG"
	;;
p)
	ZPACKAGE="${ZPACKAGE} $OPTARG"
	NCMDLINE="${NCMDLINE} -p $OPTARG"
	;;
P)
	ZADDPACKAGE="${ZADDPACKAGE} $OPTARG"
	NCMDLINE="${NCMDLINE} -P $OPTARG"
	;;
d)
	ZDIRS="${ZDIRS} $OPTARG"
	NCMDLINE="${NCMDLINE} -d $OPTARG"
	;;
D)
	ZDATASETS="${ZDATASETS} $OPTARG"
	;;
s)
	ZROSHARED="${ZROSHARED} $OPTARG"
	NCMDLINE="${NCMDLINE} -s $OPTARG"
	;;
S)
	ZSHARED="${ZSHARED} $OPTARG"
	NCMDLINE="${NCMDLINE} -S $OPTARG"
	;;
U)
	ZUSERS="${ZUSERS} $OPTARG"
	NCMDLINE="${NCMDLINE} -U $OPTARG"
	;;
n)
	NZONES="$OPTARG"
	;;
k)
	SSHKEYFILE="$OPTARG"
	NCMDLINE="${NCMDLINE} -k $OPTARG"
	CLOUDINIT="Y"
	;;
K)
	KARGS="${KARGS} $OPTARG"
	NCMDLINE="${NCMDLINE} -K $OPTARG"
	;;
F)
	FLOWPROPS="$OPTARG"
	;;
f)
	BHYVEFW="$OPTARG"
	;;
v)
	BHYVEVOL="$OPTARG"
	;;
V)
	BHYVEVOLSIZES="${BHYVEVOLSIZES} ${OPTARG}"
	;;
m)
	RAMSPEC="$OPTARG"
	NCMDLINE="${NCMDLINE} -m $OPTARG"
	;;
esac
done

#
# sadly, zones within zones aren't possible
#
THISZONE=$(/sbin/zonename)
if [ "X$THISZONE" != "Xglobal" ]; then
    echo "ERROR: zone management is only possible in the global zone"
    exit 1
fi

if [[ -z $ZNAME ]]; then
   echo "ERROR: zone name must be specified"
   usage
fi

#
# you can't create the global zone
#
if [ "X$ZNAME" = "Xglobal" ]; then
    echo "ERROR: the name global is reserved"
    exit 1
fi

#
# router is a custom pseudo-brand; check it first
# router zones are whole-root and must specify a network with -R
# reset the brand, and check and set the properties we need
# set a flag we can use later
#
# Note that router zones (-t router) are different from a proxy zone (given
# by using -R with another brand). A router zone is completely defined and
# controlled by the system, whereas a proxy zone is controlled by the user.
#
case $ZBRAND in
router)
	ZBRAND="TRIBwhole"
	ISROUTER="y"
	if [[ -z $RIP4 ]]; then
	    echo "ERROR: Must specify a network with -R for a router zone"
	    usage
	fi
	if [[ -n $ZIP4 ]]; then
	    echo "ERROR: router zones require -x, not -i"
	    usage
	fi
	if [[ -z $XIP4 ]]; then
	    echo "ERROR: router zones require a primary interface be specified with -x"
	    usage
	fi
	if [[ -n $ZBLANK ]]; then
	    echo "ERROR: router zones cannot be blank"
	    usage
	fi
	if [[ -n $NZONES ]]; then
	    echo "ERROR: cannot build multiple router zones"
	    usage
	fi
	# users cannot specify overlays for router zones
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for router zones"
	   usage
	fi
	# but we can, and do
	ZOVERLAY="base"
	# users cannot specify packages for router zones
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for router zones"
	   usage
	fi
	# but we can, and do
	# ipfilter is needed for nat, and is also needed in the global
	# zone (and is explicitly installed later if not already present)
	ZADDPACKAGE="TRIBnet-ipfilter TRIBdnsmasq TRIBblix-haproxy2"
	;;
esac

#
# normalize the brand, reject unknown brands
#
case $ZBRAND in
sparse|TRIBsparse)
	ZBRAND="TRIBsparse"
	;;
whole|TRIBwhole)
	ZBRAND="TRIBwhole"
	;;
alien|TRIBalien)
	ZBRAND="TRIBalien"
	;;
bhyve)
	ZBRAND="bhyve"
	;;
lx|SUNWlx)
	ZBRAND="SUNWlx"
	;;
s10|solaris10|SUNWsolaris10)
	ZBRAND="SUNWsolaris10"
	;;
appstack|TRIBappstack)
	ZBRAND="TRIBappstack"
	;;
*)
	echo "ERROR: unrecognized brand $ZBRAND"
	usage
	;;
esac

#
# not all brands are supported on all variants or architectures
# check here so the user knows it will never work here, rather than
# the generic 'not installed' error we would give later
#
MYARCH=$(uname -p)
if [[ $MYARCH = sparc ]]; then
    case $ZBRAND in
	bhyve)
	    echo "ERROR: bhyve zones are not supported on sparc"
	    usage
	    ;;
	SUNWlx)
	    echo "ERROR: lx zones are not supported on sparc"
	    usage
	    ;;
    esac
fi
MYVAR=$(uname -v)
if [[ $ZBRAND = SUNWlx ]]; then
    case $MYVAR in
	omnitribblix*)
	    :
	    ;;
	*)
	    echo "ERROR: lx zones are only supported on omnitribblix"
	    usage
	    ;;
    esac
fi

#
# verify arguments against brands
#
case $ZBRAND in
TRIBsparse)
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for sparse-root zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for sparse-root zones"
	   usage
	fi
	if [[ -n $ZISOFILE ]]; then
	    echo "ERROR: cannot install a sparse-root zone from an image"
	    usage
	fi
	if [ ! -d /zonelib/lib ]; then
	    /usr/bin/mkdir -p /zonelib/lib
	fi
	;;
TRIBwhole)
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZISOFILE ]]; then
	    echo "ERROR: cannot install a whole-root zone from an image"
	    usage
	fi
	;;
TRIBalien)
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for alien zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for alien zones"
	   usage
	fi
	#
	# Check that we're given an image to install. It's validated, and
	# possibly downloaded, after all the other checks have passed
	#
	if [[ -z $ZISOFILE ]]; then
	    echo "ERROR: an alien zone requires an image to be specified"
	    usage
	fi
	;;
TRIBappstack)
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for appstack zones"
	   usage
	fi
	if [[ -n $ZPACKAGE ]]; then
	   echo "ERROR: cannot specify copy packages for appstack zones"
	   usage
	fi
	if [[ -n $ZISOFILE ]]; then
	    echo "ERROR: cannot install an appstack zone from an image"
	    usage
	fi
	;;
SUNWsolaris10)
	if [ ! -f /etc/zones/SUNWsolaris10.xml ]; then
	    echo "ERROR: s10 brand not found"
	    echo "  To install, zap install TRIBsys-zones-brand-s10"
	    usage
	fi
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for s10 zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for s10 zones"
	   usage
	fi
	#
	# Check that we're given an image to install. It's validated
	# after all the other checks have passed
	#
	if [[ -z $ZISOFILE ]]; then
	    echo "ERROR: an s10 zone requires an image to be specified"
	    usage
	fi
	#
	# the zone installation script expects a different flag
	# from my alien installer:
	#
	IMGFLAG="-a"
	;;
SUNWlx)
	if [ ! -f /etc/zones/SUNWlx.xml ]; then
	    echo "ERROR: lx not found - is it available?"
	    usage
	fi
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for lx zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for lx zones"
	   usage
	fi
	#
	# Check that we're given an image to install. It's validated, and
	# possibly downloaded, after all the other checks have passed
	#
	if [[ -z $ZISOFILE ]]; then
	    echo "ERROR: an lx zone requires an image to be specified"
	    usage
	fi
	if [[ -n $ZIP4 ]]; then
	    echo "ERROR: lx zones must be exclusive-ip"
	    usage
	fi
	if [[ -n $ZBLANK ]]; then
	    echo "ERROR: lx zones cannot be blank (yet)"
	    usage
	fi
	#
	# the zone installation script expects a different flag
	# from my alien installer: -s for zfs streams, -t for tarballs
	#
	IMGFLAG="-t"
	;;
bhyve)
	if [ ! -f /var/sadm/overlays/installed/bhyve ]; then
	    echo "ERROR: bhyve not found"
	    echo "  To install, zap install-overlay bhyve"
	    usage
	fi
	if [ ! -f /usr/lib/brand/bhyve/platform.xml ]; then
	    echo "ERROR: bhyve not found - is it available?"
	    usage
	fi
	if [ ! -d /usr/share/bhyve/firmware ]; then
	    echo "ERROR: bhyve firmware not found - is it available?"
	    usage
	fi
	if [ ! -f "/usr/share/bhyve/firmware/${BHYVEFW}.fd" ]; then
	    echo "ERROR: requested bhyve firmware $BHYVEFW not found"
	    usage
	fi
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for bhyve zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for bhyve zones"
	   usage
	fi
	#
	# Check that we're either given an existing zvol or
	# given an image to install. It's validated, and
	# possibly downloaded, after all the other checks have passed
	#
	if [[ -z $BHYVEVOL && -z $ZISOFILE ]]; then
	    echo "ERROR: bhyve zones require an image or volume to be specified"
	    usage
	fi
	if [[ -n $BHYVEVOL && -n $ZISOFILE ]]; then
	    echo "ERROR: bhyve zones require only one of image or volume"
	    usage
	fi
	#
	# volume checks
	#
	if [[ -z $BHYVEVOL && -z $BHYVEVOLSIZES ]]; then
	    echo "ERROR: bhyve zones require either a zvol or size"
	    usage
	fi
	if [[ -n $BHYVEVOL && -n $BHYVEVOLSIZES ]]; then
	    echo "ERROR: bhyve zones require only one of zvol or size"
	    usage
	fi
	if [[ -n $BHYVEVOL ]]; then
	    if [[ ! -e /dev/zvol/rdsk/$BHYVEVOL ]]; then
		echo "ERROR: specified bhyve volume does not exist"
		usage
	    fi
	fi
	if [[ -n $ZIP4 ]]; then
	    echo "ERROR: bhyve zones must be exclusive-ip"
	    usage
	fi
	if [[ -n $ZBLANK ]]; then
	    echo "ERROR: bhyve zones cannot be blank"
	    usage
	fi
	if [[ -n $ZUSERS ]]; then
	    echo "ERROR: cannot assign users for bhyve zones"
	    usage
	fi
	if [[ -n $ZDIRS ]]; then
	    echo "ERROR: cannot create directories for bhyve zones"
	    usage
	fi
	if [[ -n $ZDATASETS ]]; then
	    echo "ERROR: cannot share datasets for bhyve zones"
	    usage
	fi
	#
	# the zone installation script expects a different flag
	# from my alien installer: -s for zfs streams, -t for tarballs
	#
	IMGFLAG="-t"
	;;
esac

#
# ip-type cannot be both shared and exclusive
#
if [[ -n $XIP4 && -n $ZIP4 ]]; then
    echo "ERROR: cannot specify both -i and -x"
    usage
fi

#
# we can only define a flow on a datalink, which requires a vnic
# and hence an exclusive-ip zone
#
# note that we require properties to be set; if you just want to monitor
# traffic volumes then dlstat will show stats for the vnic
#
if [[ -n $FLOWPROPS && -z $XIP4 ]]; then
    echo "ERROR: flow properties require a primary interface be specified with -x"
    usage
fi

#
# if the zone is a router/proxy (-R option) then the primary interface
# must be of type exclusive, not shared, a primary interface must be
# defined, the zone type must be whole or sparse, and you can only build
# them individually
#
if [[ -n $RIP4 && -n $ZIP4 ]]; then
    echo "ERROR: proxy zones require -x, not -i"
    usage
fi
if [[ -n $RIP4 && -z $XIP4 ]]; then
    echo "ERROR: proxy zones require a primary interface be specified with -x"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = TRIBalien ]]; then
    echo "ERROR: proxy zones must not be of type alien"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = TRIBappstack ]]; then
    echo "ERROR: proxy zones must not be of type appstack"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = SUNWsolaris10 ]]; then
    echo "ERROR: proxy zones must not be of type s10"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = SUNWlx ]]; then
    echo "ERROR: proxy zones must not be of type lx"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = bhyve ]]; then
    echo "ERROR: proxy zones must not be of type bhyve"
    usage
fi
if [[ -n $RIP4 && -n $NZONES ]]; then
    echo "ERROR: cannot build multiple proxy zones"
    usage
fi
# temporary restriction?
if [[ -n $NZONES && $ZBRAND = bhyve ]]; then
    echo "ERROR: cannot build multiple bhyve zones"
    usage
fi
if [[ -n $BHYVEVOL && $ZBRAND != bhyve ]]; then
    echo "ERROR: -v option only valid for bhyve"
    usage
fi
if [[ -n $BHYVEVOLSIZES && $ZBRAND != bhyve ]]; then
    echo "ERROR: -V option only valid for bhyve"
    usage
fi
if [[ -n $RAMSPEC ]]; then
    if [[ $RAMSPEC != *G && $RAMSPEC != *M && $RAMSPEC != *T ]]; then
	echo "ERROR: -m must be in G or M or T"
	usage
    fi
    #
    # validate against available system memory
    # this is to prevent absurd requests being made by accident,
    # and doesn't prevent overcommitment
    # heuristically, reserve the global zone 128M + 10%
    #
    AVAILRAM=$(/usr/sbin/prtconf -m)
    AVAILRAM=$((AVAILRAM-128))
    AVAILRAM=$((0.9*AVAILRAM))
    case $RAMSPEC in
	*T)
	    RAMREQ=${RAMSPEC//T}
	    RAMREQ=$((RAMREQ*1024*1024))
	    ;;
	*G)
	    RAMREQ=${RAMSPEC//G}
	    RAMREQ=$((RAMREQ*1024))
	    ;;
	*M)
	    RAMREQ=${RAMSPEC//M}
	    ;;
    esac
    if [[ $RAMREQ -gt $AVAILRAM ]]; then
	echo "ERROR: -m request exceeds available memory ${AVAILRAM}M"
	usage
    fi
fi
#
# validate cpu request against number of cpus available in system
# we don't do a full check of the vcpus syntax for bhyve, but do
# try and check the total number of cpus requested
#
if [[ -n $CPUSPEC ]]; then
    AVAILCPU=$(/usr/sbin/psrinfo -t -S on-line)
    if [[ $ZBRAND = bhyve ]]; then
	case $CPUSPEC in
	    cpus=*,*)
		CPUREQ=${CPUSPEC%%,*}
		CPUREQ=${CPUREQ/cpus=}
		if [[ $CPUREQ -gt $AVAILCPU ]]; then
		    echo "ERROR: -c request for $CPUREQ exceeds available cpus ${AVAILCPU}"
		    usage
		fi
		if [[ $CPUREQ -gt 32 ]]; then
		    echo "ERROR: -c request for $CPUREQ exceeds bhyve limit of 32"
		    usage
		fi
		;;
	    *,*)
		CPUREQ=${CPUSPEC%%,*}
		if [[ $CPUREQ -gt $AVAILCPU ]]; then
		    echo "ERROR: -c request for $CPUREQ exceeds available cpus ${AVAILCPU}"
		    usage
		fi
		if [[ $CPUREQ -gt 32 ]]; then
		    echo "ERROR: -c request for $CPUREQ exceeds bhyve limit of 32"
		    usage
		fi
		;;
	    cpus=*)
		CPUREQ=${CPUSPEC/cpus=}
		if [[ $CPUREQ -gt $AVAILCPU ]]; then
		    echo "ERROR: -c request for $CPUREQ exceeds available cpus ${AVAILCPU}"
		    usage
		fi
		if [[ $CPUREQ -gt 32 ]]; then
		    echo "ERROR: -c request for $CPUREQ exceeds bhyve limit of 32"
		    usage
		fi
		;;
	    *=*)
		echo "ERROR: invalid bhyve vcpu specification"
		usage
		;;
	    *)
		# simple case, just a number
		if [[ $CPUSPEC -gt $AVAILCPU ]]; then
		    echo "ERROR: -c request for $CPUSPEC exceeds available cpus ${AVAILCPU}"
		    usage
		fi
		if [[ $CPUSPEC -gt 32 ]]; then
		    echo "ERROR: -c request for $CPUSPEC exceeds bhyve limit of 32"
		    usage
		fi
		;;
	esac
    else
	if [[ $CPUSPEC -gt $AVAILCPU ]]; then
	    echo "ERROR: -c request exceeds available cpus ${AVAILCPU}"
	    usage
	fi
    fi
fi
if [[ -n $BHYVEVOLSIZES ]]; then
    for BHYVEVOLSIZE in $BHYVEVOLSIZES
    do
	if [[ $BHYVEVOLSIZE != *G && $BHYVEVOLSIZE != *M ]]; then
	    echo "ERROR: -V must be in G or M"
	    usage
	fi
    done
fi
if [[ -n $SSHKEYFILE ]]; then
    if [ ! -f "${SSHKEYFILE}" ]; then
	echo "ERROR: ssh key file $SSHKEYFILE does not exist"
	usage
    fi
fi

#
# check if the zone already exists
# if asked for multiple, check the zone name as a prefix
# and verify addresses are within range
#
if [[ -n $NZONES ]]; then
    if [ $NZONES -le 1 ]; then
	echo "ERROR: number of zones must be greater than 1"
	exit 1
    fi
    #
    # the address given is the address of the first zone, subsequent
    # zones increment the address, so check the last one is in range
    # the assumption here is that we have a whole subnet
    #
    for NIP in $XIP4 $ZIP4
    do
	NBEGIN=${NIP##*.}
	#
	# we assume that we can't use .1 as it's normally the router
	#
	if [ $NBEGIN -le 1 ]; then
	    echo "ERROR: base address $NIP must be at least .2"
	    exit 1
	fi
	NMAX=$(($NBEGIN+$NZONES))
	#
	# the largest valid address is 254, as 255 is broadcast
	# but the first zone adds zero to the base so we're off by one
	#
	if [ $NMAX -gt 255 ]; then
	    echo "ERROR: that many zones won't fit after $NIP"
	    exit 1
	fi
    done
    #
    # zone names are constructed by adding a number from 1..NZONES
    # to the given name, check all of them are unused
    #
    NTHIS=1
    while [ $NTHIS -le $NZONES ]
    do
	NZNAME="${ZNAME}${NTHIS}"
	/usr/sbin/zoneadm -z "$NZNAME" list > /dev/null 2>&1
	ZEXISTS=$?
	if [ $ZEXISTS -eq 0 ]; then
	    echo "ERROR: zone $NZNAME already exists"
	    exit 1
	fi
	NTHIS=$(($NTHIS+1))
    done
else
    /usr/sbin/zoneadm -z "$ZNAME" list > /dev/null 2>&1
    ZEXISTS=$?
    if [ $ZEXISTS -eq 0 ]; then
	echo "ERROR: zone $ZNAME already exists"
	exit 1
    fi
fi

#
# for any routing/proxy, verify we're being given sensible information
# It must look like a.b.c.d/n, and d must be zero
# rewrite addresses from the network address to the host address of .1
# check no other zone is routing this network
#
if [[ -n $RIP4 ]]; then
    for RIP in $RIP4
    do
	case $RIP in
	    *.*.*.*.*)
		echo "Invalid proxy network $RIP"
		echo "  Expected a.b.c.d/prefix"
		exit 2
		;;
	    */*/*)
		echo "Invalid proxy network $RIP"
		echo "  Expected a.b.c.d/prefix"
		exit 2
		;;
	    *.*.*.*/*)
		RPREFIX=${RIP##*/}
		RSUBNET=${RIP%/*}
		echo $RSUBNET | tr '.' ' '|read OCT1 OCT2 OCT3 OCT4
		if [ $OCT1 -lt 1 -o $OCT1 -gt 223 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  first octet $OCT1 out of range"
		    exit 2
		fi
		if [ $OCT2 -lt 0 -o $OCT2 -gt 255 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  second octet $OCT2 out of range"
		    exit 2
		fi
		if [ $OCT3 -lt 0 -o $OCT3 -gt 255 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  third octet $OCT3 out of range"
		    exit 2
		fi
		if [ $OCT4 -ne 0 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  fourth octet $OCT4 out of range, must be 0"
		    exit 2
		fi
		case $RPREFIX in
		    8)
			if [ $OCT2 -ne 0 ]; then
			    echo "Invalid proxy network $RIP"
			    echo "  second octet $OCT2 out of range, must be zero for /8"
			    exit 2
			fi
			if [ $OCT3 -ne 0 ]; then
			    echo "Invalid proxy address $RIP"
			    echo "  third octet $OCT3 out of range, must be zero for /8"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: "${ZSDIR}/rconfig.${OCT1}" | /usr/bin/awk '{print $NF}')
			    echo "ERROR: network $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			NRIP4="$NRIP4 ${OCT1}.${OCT2}.${OCT3}.1/${RPREFIX}"
			;;
		    16)
			if [ $OCT3 -ne 0 ]; then
			    echo "Invalid proxy address $RIP"
			    echo "  third octet $OCT3 out of range, must be zero for /16"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: "${ZSDIR}/rconfig.${OCT1}" | /usr/bin/awk '{print $NF}')
			    echo "ERROR: parent network ${OCT1}.0.0.0/8 for $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}.${OCT2}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: "${ZSDIR}/rconfig.${OCT1}.${OCT2}" | /usr/bin/awk '{print $NF}')
			    echo "ERROR: network $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			NRIP4="$NRIP4 ${OCT1}.${OCT2}.${OCT3}.1/${RPREFIX}"
			;;
		    24)
			if [ -f "${ZSDIR}/rconfig.${OCT1}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: "${ZSDIR}/rconfig.${OCT1}" | /usr/bin/awk '{print $NF}')
			    echo "ERROR: parent network ${OCT1}.0.0.0/8 for $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}.${OCT2}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: "${ZSDIR}/rconfig.${OCT1}.${OCT2}" | /usr/bin/awk '{print $NF}')
			    echo "ERROR: parent network ${OCT1}.${OCT2}.0.0/16 for $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}.${OCT2}.${OCT3}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: "${ZSDIR}/rconfig.${OCT1}.${OCT2}.${OCT3}" | /usr/bin/awk '{print $NF}')
			    echo "ERROR: network $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			NRIP4="$NRIP4 ${OCT1}.${OCT2}.${OCT3}.1/${RPREFIX}"
			;;
		    *)
			echo "Invalid proxy prefix /$RPREFIX"
			echo "  Supported values: /8 /16 /24"
			exit 2
			;;
		esac
		;;
	    *)
		echo "Invalid proxy address $RIP"
		echo "  Expected a.b.c.d/prefix"
		exit 2
		;;
	esac
    done
    ORIP4=$RIP4
    RIP4=$NRIP4
fi

#
# if given any directories to share, verify they exist
#
if [[ -n $ZSHARED ]]; then
    for DIR in $ZSHARED
    do
	if [ ! -d "${DIR}" ]; then
	    echo "ERROR: shared directory $DIR not found"
	    exit 1
	fi
    done
fi
if [[ -n $ZROSHARED ]]; then
    for DIR in $ZROSHARED
    do
	if [ ! -d "${DIR}" ]; then
	    echo "ERROR: shared directory $DIR not found"
	    exit 1
	fi
    done
fi

#
# if given datasets to delegate, verify it's a dataset and not
# a pool, by looking for a / separator
# if multiple, we will create a hierarchy, so no need to check
# and a pool is a valid choice as the parent
#
if [[ -z $NZONES ]]; then
    for DSET in $ZDATASETS
    do
	if [[ $DSET != */* ]]; then
	    echo "ERROR: dataset cannot be a top-level pool"
	    exit 1
	fi
    done
fi

#
# if given users to share, verify they and their home directory exist
# the assumption is that the user and their home directory
# are local, hence the explicit check against /etc/passwd rather than
# getent which may select from a nameservice
#
if [[ -n $ZUSERS ]]; then
    for TUSER in $ZUSERS
    do
	chk=$(/usr/bin/grep "^${TUSER}:" /etc/passwd)
	if [ -z "${chk}" ]; then
	    echo "ERROR: user $TUSER doesn't exist, cannot share"
	    exit 1
	fi
	DIR=$(/usr/bin/grep "^${TUSER}:" /etc/passwd | /usr/bin/awk -F: '{print $6}')
	if [ -z "${DIR}" ]; then
	    echo "ERROR: home for user $TUSER doesn't exist, cannot share"
	    exit 1
	fi
	if [ ! -d "${DIR}" ]; then
	    echo "ERROR: shared home directory $DIR not found"
	    exit 1
	fi
    done
fi

#
# check any overlays are valid
# -o - error if this overlay isn't installed
# -o/-O - error if this is not a valid overlay
#
for OVL in $ZOVERLAY
do
	if [ ! -f "/var/sadm/overlays/${OVL}.ovl" ]; then
	    echo "ERROR: unrecognized overlay ${OVL}"
	    exit 1
	fi
	if [ ! -f "/var/sadm/overlays/installed/${OVL}" ]; then
	    echo "ERROR: overlay ${OVL} is not installed in the global zone"
	    exit 1
	fi
done
for OVL in $ZADDOVERLAY
do
	if [ ! -f "/var/sadm/overlays/${OVL}.ovl" ]; then
	    echo "ERROR: unrecognized overlay ${OVL}"
	    exit 1
	fi
done
#
# check any packages are valid
# -p - error if this package isn't installed
#
for APKG in $ZPACKAGE
do
    NPKG=$(/usr/lib/zap/resolve-alias "$APKG")
    if [ ! -f "/var/sadm/pkg/${NPKG}/pkginfo" ]; then
	echo "ERROR: unrecognized package ${APKG}"
	exit 1
    fi
done

#
# check validity of installation images here, after all the other checks,
# so we only download images if the command is otherwise valid
#
# s10 images don't allow downloads, you must already have an image
#
# if the image name is not an absolute path then try downloading it
# and then rewrite it to be the absolute path of the file we downloaded
#
case $ZBRAND in
TRIBalien|SUNWlx)
	if [[ $ZISOFILE != /* ]]; then
	    #
	    # check validity of the name
	    #
	    DLFILE=$(${ZAPLIBDIR}/retrieve-image -n "$ZISOFILE")
	    if [[ $DLFILE = /* ]]; then
		if [ -f "$DLFILE" ]; then
		    echo "Using cached image $DLFILE for $ZISOFILE"
		    ZISOFILE="$DLFILE"
		else
		    echo "Downloading $ZISOFILE"
		    DLFILE=$(${ZAPLIBDIR}/retrieve-image "$ZISOFILE")
		    if [ -f "$DLFILE" ]; then
			echo "Using downloaded image $DLFILE for $ZISOFILE"
			ZISOFILE="$DLFILE"
		    fi
		fi
	    fi
	fi
	if [[ $ZISOFILE != /* ]]; then
	    echo "ERROR: image name must be absolute or specify a valid download"
	    usage
	fi
	if [ ! -f "$ZISOFILE" ]; then
	    echo "ERROR: specified image not found"
	    usage
	fi
	;;
SUNWsolaris10)
	if [[ $ZISOFILE != /* ]]; then
	    echo "ERROR: image name must be absolute or specify a valid download"
	    usage
	fi
	if [ ! -f "$ZISOFILE" ]; then
	    echo "ERROR: specified image not found"
	    usage
	fi
	;;
bhyve)
	# require an image if we're not passed a prefilled volume
	if [[ -n $ZISOFILE ]]; then
	    if [[ $ZISOFILE != /* ]]; then
		#
		# check validity of the name
		#
		DLFILE=$(${ZAPLIBDIR}/retrieve-image -n "$ZISOFILE")
		if [[ $DLFILE = /* ]]; then
		    if [ -f "$DLFILE" ]; then
			echo "Using cached image $DLFILE for $ZISOFILE"
			ZISOFILE="$DLFILE"
		    else
			echo "Downloading $ZISOFILE"
			DLFILE=$(${ZAPLIBDIR}/retrieve-image "$ZISOFILE")
			if [ -f "$DLFILE" ]; then
			    echo "Using downloaded image $DLFILE for $ZISOFILE"
			    ZISOFILE="$DLFILE"
			fi
		    fi
		fi
	    fi
	    if [[ $ZISOFILE != /* ]]; then
		echo "ERROR: image name must be absolute or specify a valid download"
		usage
	    fi
	    if [[ $ZISOFILE != *.iso ]]; then
		echo "ERROR: bhyve requires an iso image"
		usage
	    fi
	    if [ ! -f "$ZISOFILE" ]; then
		echo "ERROR: specified image not found"
		usage
	    fi
	fi
	;;
esac

#
# construct a zone configuration file
#

#
# we overload ZBRAND with the template; the actual brand is specified
# in the template, and note that create -t actually refers to a template.
# Verify that the template and the file systems it uses exist, and save
# the root directory of the template into ZTEMPLATEPATH for use later.
#
if [[ -n $ZTEMPLATE ]]; then
    ZBRAND=TRIBtemplate-${ZTEMPLATE}
    if [ ! -f "/etc/zones/${ZBRAND}.xml" ]; then
	echo "ERROR: no such template ${ZTEMPLATE}"
	exit 1
    fi
    UDIR=$(/usr/bin/grep 'directory=\"/usr\"' "/etc/zones/${ZBRAND}.xml" | /usr/bin/awk '{print $2}' | /usr/bin/awk -F= '{print $2}' | /usr/bin/sed 's:"::g')
    if [ ! -d "${UDIR}" ]; then
	echo "ERROR: unable to find file systems for template ${ZTEMPLATE}"
	exit 1
    fi
    ZTEMPLATEPATH=${UDIR%/usr}
fi

get_mask() {
CIDR=0
for octet in $(echo $1 | /usr/bin/sed 's:\.: :g')
do
case $octet in
255)
	CIDR=$(($CIDR+8)) ;;
254)
	CIDR=$(($CIDR+7)) ; break ;;
252)
	CIDR=$(($CIDR+6)) ; break ;;
248)
	CIDR=$(($CIDR+5)) ; break ;;
240)
	CIDR=$(($CIDR+4)) ; break ;;
224)
	CIDR=$(($CIDR+3)) ; break ;;
192)
	CIDR=$(($CIDR+2)) ; break ;;
128)
	CIDR=$(($CIDR+1)) ; break ;;
*)
	;;
esac
done
echo $CIDR
}

#
# return interface and cidr prefix for the given address
#
# first check if the given address is on an internal subnet behind a
# router/proxy zone; if so then return the interface associated with
# that router/proxy zone, as saved in the rconfig file
#
# for an exclusive-ip zone, look for the saved interface, which will
# be the etherstub to create a vnic over
#
# for a shared-ip zone, look for the saved shared-interface, which will
# be the precreated vnic over the etherstub
#
# if it's not on an internal subnet then look to see which interface
# routes traffic for the given address
#
get_net_details() {
    ISTYLE=$1
    IIP=$2
    case $ISTYLE in
	shared)
	    SRCHIFACE="shared-interface:"
	    ;;
	exclusive)
	    SRCHIFACE="interface:"
	    ;;
	*)
	    SRCHIFACE="nosuchterm"
	    ;;
    esac
    NIP=$(get_short_net ${IIP}/24)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	IFACE=$(/usr/bin/grep "${SRCHIFACE}" "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}')
	ICIDR=24
	echo "$IFACE $ICIDR"
	return
    fi
    NIP=$(get_short_net ${IIP}/16)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	IFACE=$(/usr/bin/grep "${SRCHIFACE}" "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}')
	ICIDR=16
	echo "$IFACE $ICIDR"
	return
    fi
    NIP=$(get_short_net ${IIP}/8)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	IFACE=$(/usr/bin/grep "${SRCHIFACE}" "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}')
	ICIDR=8
	echo "$IFACE $ICIDR"
	return
    fi
    IFACE=$(/usr/sbin/route -n get "$IIP" | /usr/bin/grep interface: | /usr/bin/awk '{print $NF}')
    IMASK=$(/usr/sbin/route -n get "$IIP" | /usr/bin/grep mask: | /usr/bin/awk '{print $NF}')
    ICIDR=$(get_mask "$IMASK")
    echo "$IFACE $ICIDR"
}

#
# if the given address is on an internal subnet behind a router/proxy
# zone then return the name of that router/proxy zone, as saved in the
# rconfig file
#
get_parent_zone() {
    IIP=$1
    NIP=$(get_short_net "${IIP}/24")
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	/usr/bin/grep zone: "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net "${IIP}/16")
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	/usr/bin/grep zone: "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net "${IIP}/8")
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
        /usr/bin/grep zone: "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}'
	return
    fi
}

#
# return the default gateway for the given address; if the given
# address is on an internal subnet behind a router/proxy zone then
# return the address of the router/proxy zone on that subnet, as
# saved in the rconfig file
#
# otherwise, return the system's default gateway
#
get_gateway() {
    IIP=$1
    NIP=$(get_short_net ${IIP}/24)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	/usr/bin/grep gateway: "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net ${IIP}/16)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	/usr/bin/grep gateway: "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net ${IIP}/8)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
        /usr/bin/grep gateway: "${ZSDIR}/rconfig.${NIP}" | /usr/bin/awk '{print $NF}'
	return
    fi
    /usr/sbin/route -n get default | /usr/bin/grep gateway: | /usr/bin/awk '{print $NF}'
}

#
# return the short form of the network address - just the significant octets
# we only support /8 /16 /24 for router/proxy zones so no need to check
#
get_short_net() {
    IIP=$1
    SRPREFIX=${IIP##*/}
    SRSUBNET=${IIP%/*}
    echo $SRSUBNET | tr '.' ' '|read OCT1 OCT2 OCT3 OCT4
    case $SRPREFIX in
	8)
	    echo "${OCT1}"
	    ;;
	16)
	    echo "${OCT1}.${OCT2}"
	    ;;
	24)
	    echo "${OCT1}.${OCT2}.${OCT3}"
	    ;;
    esac
}

#
# create a link-local IPv6 address for the given IPv4 address
# the way we do this is simply to convert the IPv4 address to
# hex format, this guarantees we're unique if the IPv4 address
# is unique and won't conflict with regular addresses that are
# constructed from the mac address of the interface
#
# this is only used for shared-ip stacks; exclusive-ip stacks
# use the normal mechanism based on the mac address of the vnic
#
get_link_local() {
    IIP=$1
    printf "fe80::%x%x:%x%x/10" ${IIP//./ }
}

#
# this variant is for exclusive-ip, we get the mac address of the
# vnic and construct the address based on that
#
# the complex part here is that we need to flip bit 7
# also canonical format suppresses leading zeros
#
get_mac_link_local() {
    VNIC=$1
    /usr/sbin/dladm show-vnic -p -o MACADDRESS "$VNIC" | /usr/bin/sed 's=:= =g' | read o1 o2 o3 o4 o5 o6
    integer -i2 vi=16#$o1
    integer -i2 nvi
    nvi=$(($vi ^ 2#00000010))
    integer -i16 xv=$nvi
    no1=${xv/16#/}
    if [ "$no1" = "0" ]; then
	no1=""
    fi
    if [ "$o3" = "0" ]; then
	o3=""
    fi
    if [ "$o5" = "0" ]; then
	o5=""
    fi
    printf "fe80::%s%s:%sff:fe%s:%s%s/10" "$no1" "$o2" "$o3" "$o4" "$o5" "$o6"
}

#
# here we create the configuration and output it to stdout
#
# as we build the configuration we also save details to a zconfig file
# for all zones, and an rconfig file for each subnet behind a router zone
#
# we also create any required infrastructure
# and create a destroy script that will tear all the infrastructure
# associated with a zone when it's destroyed
#
create_configuration() {
if [ ! -d "$ZSDIR" ]; then
    /usr/bin/mkdir -p "$ZSDIR"
fi
touch "${ZSDIR}/zconfig.${ZNAME}"
if [ ! -f "${ZSDIR}/destroy.${ZNAME}" ]; then
    echo "#!/bin/sh" > "${ZSDIR}/destroy.${ZNAME}"
    /usr/bin/chmod a+x "${ZSDIR}/destroy.${ZNAME}"
fi
echo "/bin/rm -f ${ZSDIR}/zconfig.${ZNAME}" >> "${ZSDIR}/destroy.${ZNAME}"
echo "brand: $ZBRAND" >> "${ZSDIR}/zconfig.${ZNAME}"
echo "zone: $ZNAME" >> "${ZSDIR}/zconfig.${ZNAME}"
if [[ $ZBRAND = bhyve ]]; then
    echo "create -b"
    echo "set brand=bhyve"
else
    echo "create -t $ZBRAND"
fi
echo "set autoboot=true"
echo "set zonepath=${ZROOTBASE}/${ZNAME}"
if [[ -n $XIP4 ]]; then
    echo "set ip-type=exclusive"
    echo "ip-type: exclusive" >> "${ZSDIR}/zconfig.${ZNAME}"
else
    echo "ip-type: shared" >> "${ZSDIR}/zconfig.${ZNAME}"
fi
#
# shared ip addresses
#
for IP in $ZIP4
do
	echo "address: $IP" >> "${ZSDIR}/zconfig.${ZNAME}"
	get_net_details shared "$IP" | read ZIFACE ZCIDR
	echo "add net"
	echo "set physical=$ZIFACE"
	echo "set address=${IP}/${ZCIDR}"
	echo "end"
	if [[ -n $DOIP6 ]]; then
	    echo "add net"
	    echo "set physical=$ZIFACE"
	    echo "set address=$(get_link_local $IP)"
	    echo "end"
	fi
	#
	# if on a routed subnet, record the name of our router zone
	#
	ZROUTER=$(get_parent_zone "$IP")
	if [[ -n $ZROUTER ]]; then
	    echo "parent_zone: $ZROUTER" >> "${ZSDIR}/zconfig.${ZNAME}"
	fi
done
#
# exclusive-ip addresses
# the address is used to construct the topology, it's up to the
# zone to manage it, but we set up a valid hostname file later
#
# we also set the allowed-address property to restrict the zone
# (only for pure ipv4, as ipv6 doesn't seem to work properly)
#
# we set up the vnic here, and save details so that we can remove it
# when the zone is destroyed
#
ZENUM=0
for IP in $XIP4
do
	echo "address: $IP" >> "${ZSDIR}/zconfig.${ZNAME}"
	get_net_details exclusive "$IP" | read ZIFACE ZCIDR
	/usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	ZESTATUS=$?
	while [ $ZESTATUS -eq 0 ]
	do
	    ZENUM=$(($ZENUM+1))
	    /usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	    ZESTATUS=$?
	done
	/usr/sbin/dladm create-vnic -l "$ZIFACE" "znic$ZENUM"
	# if flow-properties are specified, create a flow here
	if [[ -n $FLOWPROPS ]]; then
	    /usr/sbin/flowadm add-flow -l "znic$ZENUM" -a "local_ip=$IP" -p $FLOWPROPS "znic${ZENUM}flow"
	    # don't be cute, remove all flows associated with this vnic
	    echo "/usr/sbin/flowadm remove-flow -l znic$ZENUM" >> "${ZSDIR}/destroy.${ZNAME}"
	fi
	# the vnic can only be deleted after the flow has been removed
	echo "/usr/sbin/dladm delete-vnic znic$ZENUM" >> "${ZSDIR}/destroy.${ZNAME}"
	ifipmap[znic$ZENUM]=$IP/$ZCIDR
	xifipmap[znic$ZENUM]=$IP/$ZCIDR
	echo "add net"
	echo "set physical=znic$ZENUM"
	#
	# we can't use allowed-address with IPv6, see below
	# we can't use allowed-address for a router zone, as the anti-spoofing
	# protection it brings prohibits IP forwarding and NAT
	#
	if [[ -z $DOIP6 && -z $RIP4 ]]; then
	    echo "set allowed-address=$IP/$ZCIDR"
	    # defrouter populates the gateway4 value in cloud-init
	    ZGW=$(get_gateway $XIP4)
	    if [[ -n $ZGW ]]; then
		echo "set defrouter=$ZGW"
	    fi
	fi
	echo end
	# in S11 allowed-address can be a list, but in illumos
	# you need to use multiple net blocks
	# this doesn't seem to work, the IPv6 address isn't brought up
	# if allowed-address is specified
	#if [[ -n $DOIP6 ]]; then
	#    echo add net
	#    echo set physical=znic$ZENUM
	#    echo set allowed-address=$(get_mac_link_local znic$ZENUM)
	#    echo end
	#fi
	#
	# if on a routed subnet, record the name of our router zone
	#
	ZROUTER=$(get_parent_zone "$IP")
	if [[ -n $ZROUTER ]]; then
	    echo "parent_zone: $ZROUTER" >> "${ZSDIR}/zconfig.${ZNAME}"
	    #
	    # if our parent is a known router with dnsmasq, here we
	    # add a configuration file so that dnsmasq will hand out
	    # the right address and network configuration via dhcp,
	    # then restart the dnsmasq service, and mark the configuration
	    # file for cleanup when this zone gets destroyed
	    #
	    if [ -d "${ZROOTBASE}/${ZROUTER}/root/etc/dnsmasq.d" ]; then
		ZMAC=$(/usr/sbin/dladm show-vnic -p -o MACADDRESS "znic$ZENUM")
		echo "dhcp-host=${ZMAC},${ZNAME},${IP},infinite" > "${ZROOTBASE}/${ZROUTER}/root/etc/dnsmasq.d/${ZNAME}.conf"
		/usr/sbin/svcadm -z ${ZROUTER} restart network/dnsmasq
		echo "/usr/bin/rm -f ${ZROOTBASE}/${ZROUTER}/root/etc/dnsmasq.d/${ZNAME}.conf" >> "${ZSDIR}/destroy.${ZNAME}"
		echo "/usr/sbin/svcadm -z ${ZROUTER} restart network/dnsmasq" >> "${ZSDIR}/destroy.${ZNAME}"
	    fi
	    #
	    # alternatively, if the router is the global zone,
	    # do the same but locally
	    #
	    if [[ $ZROUTER = global ]]; then
		ZMAC=$(/usr/sbin/dladm show-vnic -p -o MACADDRESS "znic$ZENUM")
		echo "dhcp-host=${ZMAC},${ZNAME},${IP},infinite" > "/etc/dnsmasq.d/${ZNAME}.conf"
		/usr/sbin/svcadm restart network/dnsmasq
		echo "/usr/bin/rm -f /etc/dnsmasq.d/${ZNAME}.conf" >> "${ZSDIR}/destroy.${ZNAME}"
		echo "/usr/sbin/svcadm restart network/dnsmasq" >> "${ZSDIR}/destroy.${ZNAME}"
	    fi
	fi
done
#
# For router/proxy zones we create an etherstub for the internal virtual
# network, and create a vnic over that etherstub. The router/proxy zone
# will have the matching .1 address on that network. We also create an
# extra vnic that can be used to connect shared-ip zones to the internal
# network, as they need some form of link to run over
#
# the naming convention is that vnics attached to zones are called znic,
# while the shared vnics are called snic
#
# Note that the destroy script must have been initialized above as we
# require a router/proxy zone to have an exclusive-ip address, and we
# carry on enumerating ZENUM where we left off
#
ZRNUM=0
ZSNUM=0
ZENUM=$(($ZENUM+1))
for IP in $RIP4
do
	/usr/sbin/dladm show-etherstub "zrstub$ZRNUM" > /dev/null 2>&1
	ZRSTATUS=$?
	while [ $ZRSTATUS -eq 0 ]
	do
	    ZRNUM=$(($ZRNUM+1))
	    /usr/sbin/dladm show-etherstub "zrstub$ZRNUM" > /dev/null 2>&1
	    ZRSTATUS=$?
	done
	ZIFACE=zrstub$ZRNUM
	/usr/sbin/dladm create-etherstub "$ZIFACE"
	#
	# create the vnic attached to the router/proxy zone that's
	# connected to the routed subnet
	#
	/usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	ZESTATUS=$?
	while [ $ZESTATUS -eq 0 ]
	do
	    ZENUM=$(($ZENUM+1))
	    /usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	    ZESTATUS=$?
	done
	/usr/sbin/dladm create-vnic -l "$ZIFACE" "znic$ZENUM"
	echo "/usr/sbin/dladm delete-vnic znic$ZENUM" >> "${ZSDIR}/destroy.${ZNAME}"
	#
	# create the second vnic connected to the routed subnet
	# that can be used for shared-ip zones
	#
	# this vnic must have an IP interface enabled (ie plumbed) in
	# the global zone but doesn't need an address configured, and
	# it won't be associated with any zones at this point
	#
	/usr/sbin/dladm show-vnic "snic$ZSNUM" > /dev/null 2>&1
	ZSSTATUS=$?
	while [ $ZSSTATUS -eq 0 ]
	do
	    ZSNUM=$(($ZSNUM+1))
	    /usr/sbin/dladm show-vnic "snic$ZSNUM" > /dev/null 2>&1
	    ZSSTATUS=$?
	done
	/usr/sbin/dladm create-vnic -l "$ZIFACE" "snic$ZSNUM"
	/usr/sbin/ipadm create-if "snic$ZSNUM"
	echo "/usr/sbin/ipadm delete-if snic$ZSNUM" >> "${ZSDIR}/destroy.${ZNAME}"
	echo "/usr/sbin/dladm delete-vnic snic$ZSNUM" >> "${ZSDIR}/destroy.${ZNAME}"
	#
	# delete the etherstub after the vnics configured on it
	#
	echo "/usr/sbin/dladm delete-etherstub $ZIFACE" >> "${ZSDIR}/destroy.${ZNAME}"
	ifipmap[znic$ZENUM]=$IP
	echo "add net"
	echo "set physical=znic$ZENUM"
	echo "end"
	# save the configuration here
	ZNETNAME=$(get_short_net "$IP")
	touch "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "interface: $ZIFACE" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "shared-interface: snic$ZSNUM" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "gateway: ${IP%/*}" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "zone: ${ZNAME}" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "public-ip: ${XIP4}" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "rm ${ZSDIR}/rconfig.${ZNETNAME}" >> "${ZSDIR}/destroy.${ZNAME}"
done
#
# for Tribblix-style zones, mount the zap package cache read-only in the
# zone where zap knows to look for it
#
if [[ $ZBRAND = TRIBsparse || $ZBRAND = TRIBwhole ]]; then
	if [ ! -d /var/zap/cache ]; then
	    /usr/bin/mkdir -p /var/zap/cache
	fi
	echo "add fs"
	echo "set dir=/var/zap/global-cache"
	echo "set special=/var/zap/cache"
	echo "set type=lofs"
	echo "add options [ro,nodevices]"
	echo "end"
fi
#
# for any items shared with the zone, add them
# existence was checked earlier
#
for DSET in $ZDATASETS
do
	echo "add dataset"
	echo "set name=${DSET}"
	echo "end"
done
for DIR in $ZDIRS
do
	/usr/bin/mkdir -p "${ZFSBASE}/${ZNAME}${DIR}"
	echo "add fs"
	echo "set dir=${DIR}"
	echo "set special=${ZFSBASE}/${ZNAME}${DIR}"
	echo "set type=lofs"
	echo "add options [nodevices]"
	echo "end"
done
for DIR in $ZSHARED
do
	echo "add fs"
	echo "set dir=${DIR}"
	echo "set special=${DIR}"
	echo "set type=lofs"
	echo "add options [nodevices]"
	echo "end"
done
for DIR in $ZROSHARED
do
	echo "add fs"
	echo "set dir=${DIR}"
	echo "set special=${DIR}"
	echo "set type=lofs"
	echo "add options [ro,nodevices]"
	echo "end"
done
#
# for users, share the home directory, and give the user the
# rights to manage the zone
#
# the user is added to the relevant system files in the zone later,
# once the zone has been installed and the /etc/{passwd,group,shadow}
# files exist
#
for TUSER in $ZUSERS
do
	echo "add fs"
	DIR=$(/usr/bin/grep "^${TUSER}:" /etc/passwd | /usr/bin/awk -F: '{print $6}')
	echo "set dir=${DIR}"
	echo "set special=${DIR}"
	echo "set type=lofs"
	echo "add options [nodevices]"
	echo "end"
	echo "add admin"
	echo "set user=${TUSER}"
	echo "set auths=manage"
	echo "end"
done
#
# for lx, need to set the kernel version; ideally this would match the
# lx image installed, but the requirement is quite loose (as is shown
# by the fact that Docker works at all), so choose a reasonably modern
# default
#
if [[ $ZBRAND = SUNWlx ]]; then
	echo "add attr"
	echo "set name=kernel-version"
	echo "set type=string"
	echo "set value=4.4.15"
	echo "end"
fi
#
# memory and cpu settings, for bhyve these are passed as string attributes
# for other zone types we specify the capped-xxx resource controls
#
if [[ $ZBRAND != bhyve ]]; then
    if [[ -n $RAMSPEC ]]; then
	echo "add capped-memory"
	echo "set physical=$RAMSPEC"
	echo "end"
	echo "memory: $RAMSPEC" >> "${ZSDIR}/zconfig.${ZNAME}"
    fi
    if [[ -n $CPUSPEC ]]; then
	echo "add capped-cpu"
	echo "set ncpus=$CPUSPEC"
	echo "end"
	echo "cpus: $CPUSPEC" >> "${ZSDIR}/zconfig.${ZNAME}"
    fi
fi
#
# for bhyve, there's a list of attributes we need
#
# the initial disk must be called "bootdisk", then the remainder
# are called "diskN", where N must start from zero
#
# note that we loop over $BHYVEVOLS and $BHYVEVOL, only one will
# be set
#
if [[ $ZBRAND = bhyve ]]; then
    VOLNUM=0
    VOLSTR="bootdisk"
    for BHVOL in $BHYVEVOLS $BHYVEVOL
    do
	echo "add device"
	echo "set match=/dev/zvol/rdsk/${BHVOL}"
	echo "end"
	echo "add attr"
	echo "set name=${VOLSTR}"
	echo "set type=string"
	echo "set value=${BHVOL}"
	echo "end"
	VOLSTR=disk${VOLNUM}
	VOLNUM=$(($VOLNUM+1))
    done
    if [[ -n $ZISOFILE ]]; then
	echo "add fs"
	echo "set dir=${ZISOFILE}"
	echo "set special=${ZISOFILE}"
	echo "set type=lofs"
	echo "add options ro"
	echo "add options nodevices"
	echo "end"
	echo "add attr"
	echo "set name=cdrom"
	echo "set type=string"
	echo "set value=${ZISOFILE}"
	echo "end"
    fi
    echo "add attr"
    echo "set name=vnc"
    echo "set type=string"
    echo "set value=on"
    echo "end"
    echo "add attr"
    echo "set name=bootrom"
    echo "set type=string"
    echo "set value=${BHYVEFW}"
    echo "end"
    echo "add attr"
    echo "set name=acpi"
    echo "set type=string"
    echo "set value=off"
    echo "end"
    case $ZISOFILE in
	*omnios*|*tribblix*|*hipster*|XStream*)
    echo "add attr"
    echo "set name=xhci"
    echo "set type=string"
    echo "set value=off"
    echo "end"
	;;
    esac
    case $ZISOFILE in
	*S11-CBE*)
    echo "add attr"
    echo "set name=hostbridge"
    echo "set type=string"
    echo "set value=none"
    echo "end"
    echo "add attr"
    echo "set name=rng"
    echo "set type=string"
    echo "set value=off"
    echo "end"
    echo "add attr"
    echo "set name=type"
    echo "set type=string"
    echo "set value=windows"
    echo "end"
    echo "add attr"
    echo "set name=xhci"
    echo "set type=string"
    echo "set value=off"
    echo "end"
        ;;
    esac
    # share directories over virtfs
    # note that the fs configuration has already been done, here
    # we set the attributes for bhyve to pick them up
    # note that we set the tag to a standardised "bhyvefsN" rather than a
    # string derived from the shared name, so that's what you'll need to
    # mount in the guest, via eg
    # mount -t 9p -o trans=virtio,uname=root bhyvefs0 /mnt/foo
    VFSNUM=0
    for DIR in $ZSHARED
    do
	echo "add attr"
	echo "set name=virtfs${VFSNUM}"
	echo "set type=string"
	echo "set value=bhyvefs${VFSNUM},${DIR}"
	echo "end"
	VFSNUM=$(($VFSNUM+1))
    done
    for DIR in $ZROSHARED
    do
	echo "add attr"
	echo "set name=virtfs${VFSNUM}"
	echo "set type=string"
	echo "set value=bhyvefs${VFSNUM},${DIR},ro"
	echo "end"
	VFSNUM=$(($VFSNUM+1))
    done
    if [[ -n $RAMSPEC ]]; then
	echo "add attr"
	echo "set name=ram"
	echo "set type=string"
	echo "set value=$RAMSPEC"
	echo "end"
	echo "memory: $RAMSPEC" >> "${ZSDIR}/zconfig.${ZNAME}"
    fi
    if [[ -n $CPUSPEC ]]; then
	echo "add attr"
	echo "set name=vcpus"
	echo "set type=string"
	echo "set value=$CPUSPEC"
	echo "end"
	echo "cpus: $CPUSPEC" >> "${ZSDIR}/zconfig.${ZNAME}"
    fi
    if [[ -n $CLOUDINIT ]]; then
	echo "add attr"
	echo "set name=cloud-init"
	echo "set type=string"
	echo "set value=on"
	echo "end"
	# try and get resolvers from resolv.conf
	if [ -f /etc/resolv.conf ]; then
	    RESOLVERS=$(grep nameserver /etc/resolv.conf | awk '{printf $2","}' | sed 's:,$::')
	    if [[ -n $RESOLVERS ]]; then
		echo "add attr"
		echo "set name=resolvers"
		echo "set type=string"
		echo "set value=$RESOLVERS"
		echo "end"
	    fi
	fi
	# the file specified here is copied later into the zone at the fixed
	# location we give here, as cloud-init runs in the zone context
	if [[ -n $SSHKEYFILE ]]; then
	    echo "add attr"
	    echo "set name=sshkey"
	    echo "set type=string"
	    echo "set value=/sshkey.pub"
	    echo "end"
	fi
    fi
fi
echo "verify"
echo "commit"
}

#
# for an s10 branded zone, create a sysidcfg file
# assumes we just have a single interface
#
create_sysidcfg() {
    echo system_locale=C
    echo terminal=xterms
    echo "network_interface=primary {"
    echo "  hostname=${ZNAME}"
    if [[ -n $XIP4 ]]; then
	echo "ip_address=${XIP4}"
	IMASK=$(/usr/sbin/route -n get $XIP4 | /usr/bin/grep mask: | /usr/bin/awk '{print $NF}')
	echo "netmask=$IMASK"
	ZGW=$(get_gateway $XIP4)
	echo "default_route=$ZGW"
	if [[ -n $DOIP6 ]]; then
	    echo "protocol_ipv6=yes"
	else
	    echo "protocol_ipv6=no"
	fi
    fi
    echo "}"
    echo "security_policy=NONE"
    # we manually configure dns, so don't let sysidcfg mess it up
    echo "name_service=NONE"
    echo "nfs4_domain=dynamic"
    echo "timezone=${TZ:=UTC}"
    echo "root_password=jhDYXBAnWJKr2"
}

#
# construct the command line arguments for zoneadm install
#
create_install_opts() {
for OVL in $ZOVERLAY
do
	printf " -o $OVL"
done
for OVL in $ZADDOVERLAY
do
	printf " -O $OVL"
done
for APKG in $ZPACKAGE
do
	printf " -p $APKG"
done
for APKG in $ZADDPACKAGE
do
	printf " -P $APKG"
done
if [[ -n $ZISOFILE && $ZBRAND != bhyve ]]; then
    printf " $IMGFLAG $ZISOFILE"
fi
if [[ $ZBRAND = SUNWsolaris10 ]]; then
    printf " -u"
fi
if [[ -n $ZTEMPLATE ]]; then
    printf " -T $ZTEMPLATEPATH"
fi
}

#
# if we're creating multiple zones, do them in a loop here, and exit
#
if [[ -n $NZONES ]]; then
    #
    # the address given is the address of the first zone, subsequent
    # zones increment the address, so check the last one is in range
    # the assumption here is that we have a whole subnet
    #
    for NIP in $XIP4 $ZIP4
    do
	NBEGIN=${NIP##*.}
	#
	# we assume that we can't use .1 as it's normally the router
	#
	if [ $NBEGIN -le 1 ]; then
	    echo "ERROR: base address $NIP must be at least .2"
	    exit 1
	fi
	NMAX=$(($NBEGIN+$NZONES))
	#
	# the largest valid address is 254, as 255 is broadcast
	# but the first zone adds zero to the base so we're off by one
	#
	if [ $NMAX -gt 255 ]; then
	    echo "ERROR: that many zones won't fit after $NIP"
	    exit 1
	fi
    done
    #
    # zone names are constructed by adding a number from 1..NZONES
    # to the given name, IP addresses add 0..NZONES-1
    # hence we increment the counter in the middle
    #
    NTHIS=0
    while [ $NTHIS -lt $NZONES ]
    do
	NADDR=""
	for NIP in $XIP4
	do
	    NSUB=${NIP%.*}
	    NBEGIN=${NIP##*.}
	    NADDR="$NADDR -x ${NSUB}.$(($NBEGIN+$NTHIS))"
	done
	for NIP in $ZIP4
	do
	    NSUB=${NIP%.*}
	    NBEGIN=${NIP##*.}
	    NADDR="$NADDR -i ${NSUB}.$(($NBEGIN+$NTHIS))"
	done
	NTHIS=$(($NTHIS+1))
	NZNAME="${ZNAME}${NTHIS}"
	#
	# handle delegated datasets
	# the argument is interpreted as a prefix, with the zone name
	# (not just the zone number) tacked on, as the dataset names must be
	# unique
	#
	NDATASETS=""
	for DSET in $ZDATASETS
	do
	    NDATASETS="${NDATASETS} -D ${DSET}/${NZNAME}"
	done
	#
	# construct command for this host, with unique zone name and addresses
	#
	echo "Creating zone ${NZNAME}"
	zap create-zone -t "$ZBRAND" -z "${NZNAME}" $NADDR ${NDATASETS} $NCMDLINE
    done
    exit 0
fi

#
# create any missing zfs datasets
#
if [[ -n ${ZDIRS} ]]; then
   ZPARENT=${ZFSBASE%/*}
   ZDPARENT=$(/usr/sbin/zfs list -H "${ZPARENT}" | /usr/bin/awk '{print $1}')
   ZREALNAME=$(echo $ZFSBASE | /usr/bin/sed s:${ZPARENT}:${ZDPARENT}:)
   if [[ ! -d "${ZFSBASE}" ]]; then
      /usr/sbin/zfs create "${ZREALNAME}"
   fi
   if [[ ! -d "${ZFSBASE}/${ZNAME}" ]]; then
      /usr/sbin/zfs create "${ZREALNAME}/${ZNAME}"
   fi
fi
if [[ ! -d "${ZROOTBASE}" ]]; then
   ZPARENT=${ZROOTBASE%/*}
   ZDPARENT=$(/usr/sbin/zfs list -H "${ZPARENT}" | /usr/bin/awk '{print $1}')
   ZREALNAME=$(echo $ZROOTBASE | /usr/bin/sed s:${ZPARENT}:${ZDPARENT}:)
   /usr/sbin/zfs create "${ZREALNAME}"
fi
#
# this one is split, we create any missing intermediate datasets
# but the final dataset has an explicit mountpoint property
#
for DSET in $ZDATASETS
do
    ZPARENT=${DSET%/*}
    /usr/sbin/zfs create -p "${ZPARENT}"
    /usr/sbin/zfs create -o mountpoint=none "${DSET}"
done
#
# volumes for bhyve - create and set
#
# add to the destroy file so the volumes get destroyed along with the
# zone, if you want persistent volumes then create them first and use
# the -v flag rather than -V
#
# the specification can be either size alone, or pool:size
# to use an alternate pool
#
if [[ $ZBRAND = bhyve ]]; then
    if [[ -z $BHYVEVOL ]]; then
	if [[ -n $BHYVEVOLSIZES ]]; then
	    for BHYVEVOLSIZE in $BHYVEVOLSIZES
	    do
		case $BHYVEVOLSIZE in
		    *:*)
			BHYVEPOOL=${BHYVEVOLSIZE%:*}
			BHYVEVOLSIZE=${BHYVEVOLSIZE#*:}
			;;
		esac
		VOLENUM=0
		BVOLNAME=${ZNAME}_bhvol${VOLENUM}
		/usr/sbin/zfs get type "${BHYVEPOOL}/${BVOLNAME}" > /dev/null 2>&1
		ZESTATUS=$?
		while [ $ZESTATUS -eq 0 ]
		do
		    VOLENUM=$(($VOLENUM+1))
		    BVOLNAME=${ZNAME}_bhvol${VOLENUM}
		    /usr/sbin/zfs get type "${BHYVEPOOL}/${BVOLNAME}" > /dev/null 2>&1
		    ZESTATUS=$?
		done
		/usr/sbin/zfs create -V "$BHYVEVOLSIZE" "${BHYVEPOOL}/${BVOLNAME}"
		BHYVEVOLS="${BHYVEVOLS} ${BHYVEPOOL}/${BVOLNAME}"
		if [ ! -f "${ZSDIR}/destroy.${ZNAME}" ]; then
		    echo "#!/bin/sh" > "${ZSDIR}/destroy.${ZNAME}"
		    /usr/bin/chmod a+x "${ZSDIR}/destroy.${ZNAME}"
		fi
		echo "/usr/sbin/zfs destroy ${BHYVEPOOL}/${BVOLNAME}" >> "${ZSDIR}/destroy.${ZNAME}"
	    done
	else
	    echo "ERROR: bhyve volume logic error"
	    exit 1
	fi
    fi
fi

ZCFGFILE=/tmp/zap.zcfg.$(date '+%F-%T').$$
create_configuration > "${ZCFGFILE}"

/usr/sbin/zonecfg -z "${ZNAME}" -f "${ZCFGFILE}"

/usr/sbin/zoneadm -z "${ZNAME}" install $(create_install_opts)

#
# once the zone is installed we can do any zone configuration that
# requires manipulating files present within the zone
#

#
# copy the shared user accounts specified into the zone
# and allow them the root role if it's a Solarish type of zone
#
for TUSER in $ZUSERS
do
    /usr/bin/grep "^${TUSER}:" /etc/passwd >> "${ZROOTBASE}/${ZNAME}/root/etc/passwd"
    /usr/bin/grep "^${TUSER}:" /etc/shadow >> "${ZROOTBASE}/${ZNAME}/root/etc/shadow"
    #
    # try to make sure the shared user's group exists in the zone too
    #
    TGID=$(/usr/bin/grep "^${TUSER}:" /etc/passwd | /usr/bin/awk -F: '{print $4}')
    if [[ -n $TGID ]]; then
	if ! /usr/bin/grep -q ":${TGID}:" "${ZROOTBASE}/${ZNAME}/root/etc/group"
	then
	    /usr/bin/grep ":${TGID}:" /etc/group >> "${ZROOTBASE}/${ZNAME}/root/etc/group"
	fi
    fi
    if [[ $ZBRAND != SUNWlx ]]; then
	echo "${TUSER}::::roles=root" >> "${ZROOTBASE}/${ZNAME}/root/etc/user_attr"
    fi
done

#
# for exclusive-ip stacks:
#  create /etc/hostname.* files for each vnic we created
#  set the default route
#
if [[ $ZBRAND != SUNWlx ]]; then
    for index in "${!ifipmap[@]}"
    do
	echo "${ifipmap[$index]}" > "${ZROOTBASE}/${ZNAME}/root/etc/hostname.$index"
	if [[ -n $DOIP6 ]]; then
	    touch "${ZROOTBASE}/${ZNAME}/root/etc/hostname6.$index"
	fi
    done
    if [[ -n $XIP4 ]]; then
	ZGW=$(get_gateway $XIP4)
	echo "$ZGW" > "${ZROOTBASE}/${ZNAME}/root/etc/defaultrouter"
    fi
fi

#
# for router/proxy zones:
#  ensure ipfilter is installed in the global zone, so that the devices that
#  the zone ipfilter needs are created; note that we don't need ipfilter to
#  actually run in the global zone
#  configure nat for all subnets behind the router zone
#  enable ip forwarding on all interfaces in the zone
#
if [[ -n $RIP4 ]]; then
    if [ ! -f /var/sadm/pkg/TRIBnet-ipfilter/pkginfo ]; then
	echo "Installing ipfilter in the global zone"
	/usr/bin/zap install TRIBnet-ipfilter
	sleep 1
    fi
    touch "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    echo "#!/bin/sh" > "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    for index in "${!ifipmap[@]}"
    do
	echo "/usr/sbin/ipadm set-ifprop -t -p forwarding=on -m ipv4 $index" >> "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    done
    echo /usr/sbin/svcadm enable network/ipfilter >> "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    chmod a+x "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    IFACE=$(echo "${!xifipmap[@]}"|awk '{print $1}')
    touch "${ZROOTBASE}/${ZNAME}/root/etc/ipf/ipnat.conf"
    for subnet in $ORIP4
    do
	echo "map $IFACE $subnet -> 0/32 portmap tcp/udp auto" >> "${ZROOTBASE}/${ZNAME}/root/etc/ipf/ipnat.conf"
	echo "map $IFACE $subnet -> 0/32" >> "${ZROOTBASE}/${ZNAME}/root/etc/ipf/ipnat.conf"
    done
fi

#
# for managed router zones only, set up dnsmasq as well
#
if [[ -n $ISROUTER ]]; then
    # dnsmasq.d is where specific host configuration will be placed
    echo "conf-dir=/etc/dnsmasq.d" > "${ZROOTBASE}/${ZNAME}/root/etc/dnsmasq.conf"
    # server starts as root, then changes uid, so this is the user to change to
    # running as user dnsmasq with privileges was tested and failed
    echo "user=dnsmasq" >> "${ZROOTBASE}/${ZNAME}/root/etc/dnsmasq.conf"
    # a dhcp-range entry is required to enable the dhcp server
    # all configuration is static, we fix the IP addresses
    for subnet in $ORIP4
    do
	echo "dhcp-range=${subnet%/*},static" >> "${ZROOTBASE}/${ZNAME}/root/etc/dnsmasq.conf"
    done
    # Ensure it gets enabled on boot
    echo "/usr/sbin/svcadm enable network/dnsmasq" >> "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
fi

#
# blank the zone if requested; init requires the smf entry to be present in
# inittab but doesn't check what it actually runs
#
if [[ -n ${ZBLANK} ]]; then
    if [ -f "${ZROOTBASE}/${ZNAME}/root/etc/inittab" ]; then
        /usr/bin/sed -i 's:/lib/svc/bin/svc.startd:/usr/bin/sleep Inf:' "${ZROOTBASE}/${ZNAME}/root/etc/inittab"
    fi
fi

#
# do some minimalist configuration of the zone
#
/usr/bin/cp /etc/resolv.conf "${ZROOTBASE}/${ZNAME}/root/etc"
if [[ $ZBRAND != SUNWlx && $ZBRAND != bhyve ]]; then
    /usr/bin/cp /etc/default/init "${ZROOTBASE}/${ZNAME}/root/etc/default/init"
    echo "${ZNAME}" > "${ZROOTBASE}/${ZNAME}/root/etc/nodename"
    /usr/bin/sed -i "s:tribblix:${ZNAME}:g" "${ZROOTBASE}/${ZNAME}/root/etc/inet/hosts"
fi

#
# populate a sysidcfg file if we're an s10 branded zone
# sysidcfg resets nsswitch to none, so thwart that
# Copy in more minimal profile and .login to avoid
# attempts to run quota at login (which will likely not work)
#
if [[ $ZBRAND = SUNWsolaris10 ]]; then
    SYSIDCFGFILE=/tmp/zap.sysidcfg.${ZNAME}.$(date '+%F-%T').$$
    create_sysidcfg > "${SYSIDCFGFILE}"
    /usr/bin/cp "${SYSIDCFGFILE}" "${ZROOTBASE}/${ZNAME}/root/etc/sysidcfg"
    /usr/bin/cp "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.dns" "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.files"
    /usr/bin/cp "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.dns" "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.conf"
    /usr/bin/cp /etc/.login "${ZROOTBASE}/${ZNAME}/root/etc/.login"
    /usr/bin/cp /etc/profile "${ZROOTBASE}/${ZNAME}/root/etc/profile"
fi

#
# copy an ssh key to wherever the zone might expect it
# not for appstack zones, which aren't expected to be running ssh
#
if [[ -n "$SSHKEYFILE" ]]; then
    if [[ $ZBRAND = bhyve ]]; then
	# the /sshkey.pub name here must match the zone attribute
	/usr/bin/cp "$SSHKEYFILE" "${ZROOTBASE}/${ZNAME}/root/sshkey.pub"
    fi
    if [[ $ZBRAND = TRIBwhole || $ZBRAND = TRIBsparse || $ZBRAND = TRIBalien ]]; then
	# assume all illumos-type zones have the same directory structure
	UHOME=$(/usr/bin/awk -F: '{if ($1 == "root") print $6}' ${ZROOTBASE}/${ZNAME}/root/etc/passwd)
	if [ -n "$UHOME" ]; then
	    /usr/bin/mkdir -p -m 700 "${ZROOTBASE}/${ZNAME}/root/${UHOME}/.ssh"
	    /usr/bin/cp "$SSHKEYFILE" "${ZROOTBASE}/${ZNAME}/root/${UHOME}/.ssh/authorized_keys"
	    /usr/bin/chmod 600 "${ZROOTBASE}/${ZNAME}/root/${UHOME}/.ssh/authorized_keys"
	    /usr/bin/sed -i 's:^PermitRootLogin.*:PermitRootLogin without-password:' "${ZROOTBASE}/${ZNAME}/root/etc/ssh/sshd_config"
	fi
    fi
fi

#
# apply any konfiguration requests
#
for KARG in $KARGS
do
    ${ZAPLIBDIR}/zone-konfigurator -z "${ZNAME}" $KARG
done

/usr/sbin/zoneadm -z "${ZNAME}" boot
/usr/bin/rm "$ZCFGFILE"

if [[ -n ${SYSIDCFGFILE} ]]; then
    /usr/bin/rm -f "$SYSIDCFGFILE"
fi
