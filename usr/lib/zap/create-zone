#!/bin/ksh
#
# Create a zone
#
# Usage:
#  -6 set up link-local ipv6 addresses
#  -B blank boot
#  -c cpu allocation (vcpus for bhyve, limit for others)
#  -C enable cloud-init
#  -d directory to create [can be multiple]
#  -D dataset to delegate [will be created if it doesn't exist]
#  -f bhyve firmware (in /usr/share/bhyve/firmware)
#  -F create a flow with the given properties
#  -i IPv4 address [can be multiple, for shared-ip]
#  -I image file to install for alien, s10, bhyve, or lx zone
#  -k ssh public key, enables cloud-init
#  -K konfigurator arguments
#  -m ram allocation (size for bhyve, limit for others)
#  -n create this many zones, all the same
#  -o overlay for partial root [can be multiple, passed to install]
#  -O add overlay [can be multiple, passed to install]
#  -p package for partial root [can be multiple, passed to install]
#  -P add package [can be multiple, passed to install]
#  -R Ipv4 network to proxy, in CIDR notation
#  -s share directory r/o with the zone
#  -S share directory r/w with the zone
#  -t brand - sparse, whole, alien, s10, bhyve, or lx [default sparse]
#  -T template (implies sparse)
#  -U share user and their homedir with the zone
#  -v existing zvol for bhyve to use
#  -V size of new volume for bhyve (may be repeated)
#  -x IPv4 address [can be multiple, for exclusive-ip]
#  -z zone_name - zone name [required]
#
# FIXMES:
# add full IPv6
# add appstack overlays for sparse zones
#

ZAPLIBDIR="/usr/lib/zap"
ZFSBASE="/export/zonedata"
ZROOTBASE="/export/zones"
ZSDIR="/var/zap/zones"
ZBRAND=TRIBsparse
ZNAME=""
ZIP4=""
XIP4=""
RIP4=""
NRIP4=""
ORIP4=""
ZISOFILE=""
IMGFLAG="-i"
ZOVERLAY=""
ZADDOVERLAY=""
ZPACKAGE=""
ZADDPACKAGE=""
ZDIRS=""
ZDATASETS=""
ZSHARED=""
ZROSHARED=""
ZUSERS=""
ZTEMPLATE=""
ZBLANK=""
NZONES=""
KARGS=""
DOIP6=""
NCMDLINE=""
SYSIDCFGFILE=""
FLOWPROPS=""
BHYVEVOL=""
BHYVEVOLSIZES=""
RAMSPEC=""
BHYVEPOOL="rpool"
BHYVEFW=BHYVE_RELEASE
CLOUDINIT=""
SSHKEYFILE=""
ISROUTER=""
CPUSPEC=""

#
# these associative arrays track the interface to address mapping
#
typeset -A ifipmap
typeset -A xifipmap

usage() {
    LXUSAGE=""
    S10USAGE=""
    BHYVEUSAGE=""
    VOLUSAGE=""
    MEMUSAGE=" [-m ram_size]"
    if [ -f /etc/zones/SUNWlx.xml ]; then
	LXUSAGE="|lx"
    fi
    if [ -f /etc/zones/SUNWsolaris10.xml ]; then
	S10USAGE="|s10"
    fi
    if [ -f /usr/lib/brand/bhyve/platform.xml ]; then
	BHYVEUSAGE="|bhyve"
	VOLUSAGE=" [-v volume | -V volsize]"
	MEMUSAGE=" [-m ram_size] [-f firmware]"
    fi
    echo "Usage: $0 -z zone_name [-t whole|sparse|alien${BHYVEUSAGE}${LXUSAGE}${S10USAGE}|router]"
    echo "  [-T template] [-I image_file] [-U user]"
    echo "  [-i ip_address] [-x ip_address] [-R ip_network/prefix] [-6]"
    echo "  [-o overlay] [-O overlay] [-p package] [-P package]"
    echo "  [-d extra_dir] [-s|-S shared_dir] [-D dataset]${VOLUSAGE}"
    echo "  [-B] [-n number_of_zones] [-F flow_props]${MEMUSAGE}"
    echo "  [-c cpu_spec] [-C] [-k sshkey_file]"
    #echo "  [-K action=arg[=arg...]]"
    exit 1
}

while getopts "6Bc:Cd:D:f:F:i:I:k:K:m:n:o:O:p:P:R:s:S:t:T:U:v:V:x:z:" opt; do
case $opt in
6)
	DOIP6="Y"
	NCMDLINE="${NCMDLINE} -6"
	;;
B)
	ZBLANK="Y"
	NCMDLINE="${NCMDLINE} -B"
	;;
c)
	CPUSPEC="$OPTARG"
	NCMDLINE="${NCMDLINE} -c $OPTARG"
	;;
C)
	CLOUDINIT="Y"
	NCMDLINE="${NCMDLINE} -C"
	;;
T)
	ZTEMPLATE="$OPTARG"
	;;
t)
	ZBRAND="$OPTARG"
	;;
z)
	ZNAME="$OPTARG"
	;;
i)
	ZIP4="${ZIP4} $OPTARG"
	;;
x)
	XIP4="${XIP4} $OPTARG"
	;;
R)
	RIP4="${RIP4} $OPTARG"
	;;
I)
	ZISOFILE="$OPTARG"
	NCMDLINE="${NCMDLINE} -I $OPTARG"
	;;
o)
	ZOVERLAY="${ZOVERLAY} $OPTARG"
	NCMDLINE="${NCMDLINE} -o $OPTARG"
	;;
O)
	ZADDOVERLAY="${ZADDOVERLAY} $OPTARG"
	NCMDLINE="${NCMDLINE} -O $OPTARG"
	;;
p)
	ZPACKAGE="${ZPACKAGE} $OPTARG"
	NCMDLINE="${NCMDLINE} -p $OPTARG"
	;;
P)
	ZADDPACKAGE="${ZADDPACKAGE} $OPTARG"
	NCMDLINE="${NCMDLINE} -P $OPTARG"
	;;
d)
	ZDIRS="${ZDIRS} $OPTARG"
	NCMDLINE="${NCMDLINE} -d $OPTARG"
	;;
D)
	ZDATASETS="${ZDATASETS} $OPTARG"
	;;
s)
	ZROSHARED="${ZROSHARED} $OPTARG"
	NCMDLINE="${NCMDLINE} -s $OPTARG"
	;;
S)
	ZSHARED="${ZSHARED} $OPTARG"
	NCMDLINE="${NCMDLINE} -S $OPTARG"
	;;
U)
	ZUSERS="${ZUSERS} $OPTARG"
	NCMDLINE="${NCMDLINE} -U $OPTARG"
	;;
n)
	NZONES="$OPTARG"
	;;
k)
	SSHKEYFILE="$OPTARG"
	NCMDLINE="${NCMDLINE} -k $OPTARG"
	CLOUDINIT="Y"
	;;
K)
	KARGS="${KARGS} $OPTARG"
	NCMDLINE="${NCMDLINE} -K $OPTARG"
	;;
F)
	FLOWPROPS="$OPTARG"
	;;
f)
	BHYVEFW="$OPTARG"
	;;
v)
	BHYVEVOL="$OPTARG"
	;;
V)
	BHYVEVOLSIZES="${BHYVEVOLSIZES} ${OPTARG}"
	;;
m)
	RAMSPEC="$OPTARG"
	NCMDLINE="${NCMDLINE} -m $OPTARG"
	;;
esac
done

THISZONE=$(/sbin/zonename)
if [ "X$THISZONE" != "Xglobal" ]; then
    echo "ERROR: zone management is only possible in the global zone"
    exit 1
fi

if [[ -z $ZNAME ]]; then
   echo "ERROR: zone name must be specified"
   usage
fi

#
# you can't create the global zone
#
if [ "X$ZNAME" = "Xglobal" ]; then
    echo "ERROR: the name global is reserved"
    exit 1
fi

#
# router is a custom pseudo-brand; check it first
# router zones are whole-root and must specify a network with -R
# reset the brand, and check and set the properties we need
# set a flag we can use later
#
# Note that router zones (-t router) are different from a proxy zone (given
# by using -R with another brand). A router zone is completely defined and
# controlled by the system, whereas a proxy zone is controlled by the user.
#
case $ZBRAND in
router)
	ZBRAND="TRIBwhole"
	ISROUTER="y"
	if [[ -z $RIP4 ]]; then
	    echo "ERROR: Must specify a network with -R for a router zone"
	    usage
	fi
	if [[ -n $ZIP4 ]]; then
	    echo "ERROR: router zones require -x, not -i"
	    usage
	fi
	if [[ -z $XIP4 ]]; then
	    echo "ERROR: router zones require a primary interface be specified with -x"
	    usage
	fi
	if [[ -n $ZBLANK ]]; then
	    echo "ERROR: router zones cannot be blank"
	    usage
	fi
	if [[ -n $NZONES ]]; then
	    echo "ERROR: cannot build multiple router zones"
	    usage
	fi
	# users cannot specify overlays for router zones
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for router zones"
	   usage
	fi
	# but we can, and do
	ZOVERLAY="base"
	# users cannot specify packages for router zones
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for router zones"
	   usage
	fi
	# but we can, and do
	# ipfilter is needed for nat, and is also needed in the global
	# zone (and is explicitly installed later if not already present)
	ZADDPACKAGE="TRIBnet-ipfilter TRIBdnsmasq TRIBblix-haproxy2"
	;;
esac

#
# normalize the brand, reject unknown brands
#
case $ZBRAND in
sparse|TRIBsparse)
	ZBRAND="TRIBsparse"
	;;
whole|TRIBwhole)
	ZBRAND="TRIBwhole"
	;;
alien|TRIBalien)
	ZBRAND="TRIBalien"
	;;
bhyve)
	ZBRAND="bhyve"
	;;
lx|SUNWlx)
	ZBRAND="SUNWlx"
	;;
s10|solaris10|SUNWsolaris10)
	ZBRAND="SUNWsolaris10"
	;;
*)
	echo "ERROR: unrecognized brand $ZBRAND"
	usage
	;;
esac

#
# not all brands are supported on all variants or architectures
# check here so the user knows it will never work here, rather thah
# the 'not installed' error we would give later
#
MYARCH=$(uname -p)
if [[ $MYARCH = sparc ]]; then
    case $ZBRAND in
	bhyve)
	    echo "ERROR: bhyve zones are not supported on sparc"
	    usage
	    ;;
	SUNWlx)
	    echo "ERROR: lx zones are not supported on sparc"
	    usage
	    ;;
    esac
fi
MYVAR=$(uname -v)
if [[ $ZBRAND = SUNWlx ]]; then
    case $MYVAR in
	omnitribblix*)
	    :
	    ;;
	*)
	    echo "ERROR: lx zones are only supported on omnitribblix"
	    usage
	    ;;
    esac
fi

#
# verify arguments against brands
#
case $ZBRAND in
TRIBsparse)
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for sparse-root zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for sparse-root zones"
	   usage
	fi
	if [[ -n $ZISOFILE ]]; then
	    echo "ERROR: cannot install a sparse-root zone from an image"
	    usage
	fi
	if [ ! -d /zonelib/lib ]; then
	    /usr/bin/mkdir -p /zonelib/lib
	fi
	;;
TRIBwhole)
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZISOFILE ]]; then
	    echo "ERROR: cannot install a whole-root zone from an image"
	    usage
	fi
	;;
TRIBalien)
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for alien zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for alien zones"
	   usage
	fi
	#
	# Check that we're given an image to install. It's validated, and
	# possibly downloaded, after all the other checks have passed
	#
	if [[ -z $ZISOFILE ]]; then
	    echo "ERROR: an alien zone requires an image to be specified"
	    usage
	fi
	;;
SUNWsolaris10)
	if [ ! -f /etc/zones/SUNWsolaris10.xml ]; then
	    echo "ERROR: s10 brand not found"
	    echo "  To install, zap install TRIBsys-zones-brand-s10"
	    usage
	fi
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for s10 zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for s10 zones"
	   usage
	fi
	#
	# Check that we're given an image to install. It's validated
	# after all the other checks have passed
	#
	if [[ -z $ZISOFILE ]]; then
	    echo "ERROR: an s10 zone requires an image to be specified"
	    usage
	fi
	#
	# the zone installation script expects a different flag
	# from my alien installer:
	#
	IMGFLAG="-a"
	;;
SUNWlx)
	if [ ! -f /etc/zones/SUNWlx.xml ]; then
	    echo "ERROR: lx not found - is it available?"
	    usage
	fi
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for lx zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for lx zones"
	   usage
	fi
	#
	# Check that we're given an image to install. It's validated, and
	# possibly downloaded, after all the other checks have passed
	#
	if [[ -z $ZISOFILE ]]; then
	    echo "ERROR: an lx zone requires an image to be specified"
	    usage
	fi
	if [[ -n $ZIP4 ]]; then
	    echo "ERROR: lx zones must be exclusive-ip"
	    usage
	fi
	if [[ -n $ZBLANK ]]; then
	    echo "ERROR: lx zones cannot be blank (yet)"
	    usage
	fi
	#
	# the zone installation script expects a different flag
	# from my alien installer: -s for zfs streams, -t for tarballs
	#
	IMGFLAG="-t"
	;;
bhyve)
	if [ ! -f /var/sadm/overlays/installed/bhyve ]; then
	    echo "ERROR: bhyve not found"
	    echo "  To install, zap install-overlay bhyve"
	    usage
	fi
	if [ ! -f /usr/lib/brand/bhyve/platform.xml ]; then
	    echo "ERROR: bhyve not found - is it available?"
	    usage
	fi
	if [ ! -d /usr/share/bhyve/firmware ]; then
	    echo "ERROR: bhyve firmware not found - is it available?"
	    usage
	fi
	if [ ! -f "/usr/share/bhyve/firmware/${BHYVEFW}.fd" ]; then
	    echo "ERROR: requested bhyve firmware $BHYVEFW not found"
	    usage
	fi
	if [[ -n $ZTEMPLATE ]]; then
	    echo "ERROR: templates must be sparse-root"
	    usage
	fi
	if [[ -n $ZOVERLAY || -n $ZADDOVERLAY ]]; then
	   echo "ERROR: cannot specify overlays for bhyve zones"
	   usage
	fi
	if [[ -n $ZPACKAGE || -n $ZADDPACKAGE ]]; then
	   echo "ERROR: cannot specify packages for bhyve zones"
	   usage
	fi
	#
	# Check that we're either given an existing zvol or
	# given an image to install. It's validated, and
	# possibly downloaded, after all the other checks have passed
	#
	if [[ -z $BHYVEVOL && -z $ZISOFILE ]]; then
	    echo "ERROR: bhyve zones require an image or volume to be specified"
	    usage
	fi
	if [[ -n $BHYVEVOL && -n $ZISOFILE ]]; then
	    echo "ERROR: bhyve zones require only one of image or volume"
	    usage
	fi
	#
	# volume checks
	#
	if [[ -z $BHYVEVOL && -z $BHYVEVOLSIZES ]]; then
	    echo "ERROR: bhyve zones require either a zvol or size"
	    usage
	fi
	if [[ -n $BHYVEVOL && -n $BHYVEVOLSIZES ]]; then
	    echo "ERROR: bhyve zones require only one of zvol or size"
	    usage
	fi
	if [[ -n $BHYVEVOL ]]; then
	    if [[ ! -e /dev/zvol/rdsk/$BHYVEVOL ]]; then
		echo "ERROR: specified bhyve volume does not exist"
		usage
	    fi
	fi
	if [[ -n $ZIP4 ]]; then
	    echo "ERROR: bhyve zones must be exclusive-ip"
	    usage
	fi
	if [[ -n $ZBLANK ]]; then
	    echo "ERROR: bhyve zones cannot be blank"
	    usage
	fi
	if [[ -n $ZUSERS ]]; then
	    echo "ERROR: cannot assign users for bhyve zones"
	    usage
	fi
	if [[ -n $ZDIRS ]]; then
	    echo "ERROR: cannot create directories for bhyve zones"
	    usage
	fi
	if [[ -n $ZDATASETS ]]; then
	    echo "ERROR: cannot share datasets for bhyve zones"
	    usage
	fi
	#
	# the zone installation script expects a different flag
	# from my alien installer: -s for zfs streams, -t for tarballs
	#
	IMGFLAG="-t"
	;;
esac

#
# ip-type cannot be both shared and exclusive
#
if [[ -n $XIP4 && -n $ZIP4 ]]; then
    echo "ERROR: cannot specify both -i and -x"
    usage
fi

#
# we can only define a flow on a datalink, which requires a vnic
# and hence an exclusive-ip zone
#
# note that we require properties to be set; if you just want to monitor
# traffic volumes then dlstat will show stats for the vnic
#
if [[ -n $FLOWPROPS && -z $XIP4 ]]; then
    echo "ERROR: flow properties require a primary interface be specified with -x"
    usage
fi

#
# if the zone is a router/proxy (-R option) then the primary interface
# must be of type exclusive, not shared, a primary interface must be
# defined, the zone type must be whole or sparse, and you can only build
# them individually
#
if [[ -n $RIP4 && -n $ZIP4 ]]; then
    echo "ERROR: proxy zones require -x, not -i"
    usage
fi
if [[ -n $RIP4 && -z $XIP4 ]]; then
    echo "ERROR: proxy zones require a primary interface be specified with -x"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = TRIBalien ]]; then
    echo "ERROR: proxy zones must not be of type alien"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = SUNWsolaris10 ]]; then
    echo "ERROR: proxy zones must not be of type s10"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = SUNWlx ]]; then
    echo "ERROR: proxy zones must not be of type lx"
    usage
fi
if [[ -n $RIP4 && $ZBRAND = bhyve ]]; then
    echo "ERROR: proxy zones must not be of type bhyve"
    usage
fi
if [[ -n $RIP4 && -n $NZONES ]]; then
    echo "ERROR: cannot build multiple proxy zones"
    usage
fi
# temporary restriction?
if [[ -n $NZONES && $ZBRAND = bhyve ]]; then
    echo "ERROR: cannot build multiple bhyve zones"
    usage
fi
if [[ -n $BHYVEVOL && $ZBRAND != bhyve ]]; then
    echo "ERROR: -v option only valid for bhyve"
    usage
fi
if [[ -n $BHYVEVOLSIZES && $ZBRAND != bhyve ]]; then
    echo "ERROR: -V option only valid for bhyve"
    usage
fi
if [[ -n $RAMSPEC ]]; then
    if [[ $RAMSPEC != *G && $RAMSPEC != *M ]]; then
	echo "ERROR: -m must be in G or M"
	usage
    fi
fi
if [[ -n $BHYVEVOLSIZES ]]; then
    for BHYVEVOLSIZE in $BHYVEVOLSIZES
    do
	if [[ $BHYVEVOLSIZE != *G && $BHYVEVOLSIZE != *M ]]; then
	    echo "ERROR: -V must be in G or M"
	    usage
	fi
    done
fi
if [[ -n $SSHKEYFILE ]]; then
    if [ ! -f "${SSHKEYFILE}" ]; then
	echo "ERROR: ssh key file $SSHKEYFILE does not exist"
	usage
    fi
fi

#
# check if the zone already exists
# if asked for multiple, check the zone name as a prefix
# and verify addresses are within range
#
if [[ -n $NZONES ]]; then
    if [ $NZONES -le 1 ]; then
	echo "ERROR: number of zones must be greater than 1"
	exit 1
    fi
    #
    # the address given is the address of the first zone, subsequent
    # zones increment the address, so check the last one is in range
    # the assumption here is that we have a whole subnet
    #
    for NIP in $XIP4 $ZIP4
    do
	NBEGIN=${NIP##*.}
	#
	# we assume that we can't use .1 as it's normally the router
	#
	if [ $NBEGIN -le 1 ]; then
	    echo "ERROR: base address $NIP must be at least .2"
	    exit 1
	fi
	NMAX=$(($NBEGIN+$NZONES))
	#
	# the largest valid address is 254, as 255 is broadcast
	# but the first zone adds zero to the base so we're off by one
	#
	if [ $NMAX -gt 255 ]; then
	    echo "ERROR: that many zones won't fit after $NIP"
	    exit 1
	fi
    done
    #
    # zone names are constructed by adding a number from 1..NZONES
    # to the given name, check all of them are unused
    #
    NTHIS=1
    while [ $NTHIS -le $NZONES ]
    do
	NZNAME="${ZNAME}${NTHIS}"
	/usr/sbin/zoneadm -z "$NZNAME" list > /dev/null 2>&1
	ZEXISTS=$?
	if [ $ZEXISTS -eq 0 ]; then
	    echo "ERROR: zone $NZNAME already exists"
	    exit 1
	fi
	NTHIS=$(($NTHIS+1))
    done
else
    /usr/sbin/zoneadm -z "$ZNAME" list > /dev/null 2>&1
    ZEXISTS=$?
    if [ $ZEXISTS -eq 0 ]; then
	echo "ERROR: zone $ZNAME already exists"
	exit 1
    fi
fi

#
# for any routing/proxy, verify we're being given sensible information
# It must look like a.b.c.d/n, and d must be zero
# rewrite addresses from the network address to the host address of .1
# check no other zone is routing this network
#
if [[ -n $RIP4 ]]; then
    for RIP in $RIP4
    do
	case $RIP in
	    *.*.*.*.*)
		echo "Invalid proxy network $RIP"
		echo "  Expected a.b.c.d/prefix"
		exit 2
		;;
	    */*/*)
		echo "Invalid proxy network $RIP"
		echo "  Expected a.b.c.d/prefix"
		exit 2
		;;
	    *.*.*.*/*)
		RPREFIX=${RIP##*/}
		RSUBNET=${RIP%/*}
		echo $RSUBNET | tr '.' ' '|read OCT1 OCT2 OCT3 OCT4
		if [ $OCT1 -lt 1 -o $OCT1 -gt 223 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  first octet $OCT1 out of range"
		    exit 2
		fi
		if [ $OCT2 -lt 0 -o $OCT2 -gt 255 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  second octet $OCT2 out of range"
		    exit 2
		fi
		if [ $OCT3 -lt 0 -o $OCT3 -gt 255 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  third octet $OCT3 out of range"
		    exit 2
		fi
		if [ $OCT4 -ne 0 ]; then
		    echo "Invalid proxy network $RIP"
		    echo "  fourth octet $OCT4 out of range, must be 0"
		    exit 2
		fi
		case $RPREFIX in
		    8)
			if [ $OCT2 -ne 0 ]; then
			    echo "Invalid proxy network $RIP"
			    echo "  second octet $OCT2 out of range, must be zero for /8"
			    exit 2
			fi
			if [ $OCT3 -ne 0 ]; then
			    echo "Invalid proxy address $RIP"
			    echo "  third octet $OCT3 out of range, must be zero for /8"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: ${ZSDIR}/rconfig.${OCT1} | /usr/bin/awk '{print $NF}')
			    echo "ERROR: network $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			NRIP4="$NRIP4 ${OCT1}.${OCT2}.${OCT3}.1/${RPREFIX}"
			;;
		    16)
			if [ $OCT3 -ne 0 ]; then
			    echo "Invalid proxy address $RIP"
			    echo "  third octet $OCT3 out of range, must be zero for /16"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: ${ZSDIR}/rconfig.${OCT1} | /usr/bin/awk '{print $NF}')
			    echo "ERROR: parent network ${OCT1}.0.0.0/8 for $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}.${OCT2}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: ${ZSDIR}/rconfig.${OCT1}.${OCT2} | /usr/bin/awk '{print $NF}')
			    echo "ERROR: network $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			NRIP4="$NRIP4 ${OCT1}.${OCT2}.${OCT3}.1/${RPREFIX}"
			;;
		    24)
			if [ -f "${ZSDIR}/rconfig.${OCT1}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: ${ZSDIR}/rconfig.${OCT1} | /usr/bin/awk '{print $NF}')
			    echo "ERROR: parent network ${OCT1}.0.0.0/8 for $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}.${OCT2}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: ${ZSDIR}/rconfig.${OCT1}.${OCT2} | /usr/bin/awk '{print $NF}')
			    echo "ERROR: parent network ${OCT1}.${OCT2}.0.0/16 for $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			if [ -f "${ZSDIR}/rconfig.${OCT1}.${OCT2}.${OCT3}" ]; then
			    ZOWNER=$(/usr/bin/grep zone: ${ZSDIR}/rconfig.${OCT1}.${OCT2}.${OCT3} | /usr/bin/awk '{print $NF}')
			    echo "ERROR: network $RIP is already in use by zone $ZOWNER"
			    exit 2
			fi
			NRIP4="$NRIP4 ${OCT1}.${OCT2}.${OCT3}.1/${RPREFIX}"
			;;
		    *)
			echo "Invalid proxy prefix /$RPREFIX"
			echo "  Supported values: /8 /16 /24"
			exit 2
			;;
		esac
		;;
	    *)
		echo "Invalid proxy address $RIP"
		echo "  Expected a.b.c.d/prefix"
		exit 2
		;;
	esac
    done
    ORIP4=$RIP4
    RIP4=$NRIP4
fi

#
# if given any directories to share, verify they exist
#
if [[ -n $ZSHARED ]]; then
    for DIR in $ZSHARED
    do
	if [ ! -d "${DIR}" ]; then
	    echo "ERROR: shared directory $DIR not found"
	    exit 1
	fi
    done
fi
if [[ -n $ZROSHARED ]]; then
    for DIR in $ZROSHARED
    do
	if [ ! -d "${DIR}" ]; then
	    echo "ERROR: shared directory $DIR not found"
	    exit 1
	fi
    done
fi

#
# if given datasets to delegate, verify it's a dataset and not
# a pool, by looking for a / separator
# if multiple, we will create a hierarchy, so no need to check
# and a pool is a valid choice as the parent
#
if [[ -z $NZONES ]]; then
    for DSET in $ZDATASETS
    do
	if [[ $DSET != */* ]]; then
	    echo "ERROR: dataset cannot be a top-level pool"
	    exit 1
	fi
    done
fi

#
# if given users to share, verify they and their home directory exist
# the assumption is that the user and their home directory
# are local, hence the explicit check against /etc/passwd rather than
# getent which may select from a nameservice
#
if [[ -n $ZUSERS ]]; then
    for TUSER in $ZUSERS
    do
	chk=$(/usr/bin/grep "^${TUSER}:" /etc/passwd)
	if [ -z "${chk}" ]; then
	    echo "ERROR: user $TUSER doesn't exist, cannot share"
	    exit 1
	fi
	DIR=$(/usr/bin/grep "^${TUSER}:" /etc/passwd | /usr/bin/awk -F: '{print $6}')
	if [ -z "${DIR}" ]; then
	    echo "ERROR: home for user $TUSER doesn't exist, cannot share"
	    exit 1
	fi
	if [ ! -d "${DIR}" ]; then
	    echo "ERROR: shared home directory $DIR not found"
	    exit 1
	fi
    done
fi

#
# check any overlays are valid
# -o - error if this overlay isn't installed
# -o/-O - error if this is not a valid overlay 
#
for OVL in $ZOVERLAY
do
	if [ ! -f "/var/sadm/overlays/${OVL}.ovl" ]; then
	    echo "ERROR: unrecognized overlay ${OVL}"
	    exit 1
	fi
	if [ ! -f "/var/sadm/overlays/installed/${OVL}" ]; then
	    echo "ERROR: overlay ${OVL} is not installed in the global zone"
	    exit 1
	fi
done
for OVL in $ZADDOVERLAY
do
	if [ ! -f "/var/sadm/overlays/${OVL}.ovl" ]; then
	    echo "ERROR: unrecognized overlay ${OVL}"
	    exit 1
	fi
done
#
# check any packages are valid
# -p - error if this package isn't installed
#
for APKG in $ZPACKAGE
do
    NPKG=$(/usr/lib/zap/resolve-alias $APKG)
    if [ ! -f "/var/sadm/pkg/${NPKG}/pkginfo" ]; then
	echo "ERROR: unrecognized package ${APKG}"
	exit 1
    fi
done

#
# check validity of installation images here, after all the other checks,
# so we only download images if the command is otherwise valid
#
# s10 images don't allow downloads, you must already have an image
#
# if the image name is not an absolute path then try downloading it
# and then rewrite it to be the absolute path of the file we downloaded
#
case $ZBRAND in
TRIBalien|SUNWlx)
	if [[ $ZISOFILE != /* ]]; then
	    #
	    # check validity of the name
	    #
	    DLFILE=$(${ZAPLIBDIR}/retrieve-image -n $ZISOFILE)
	    if [[ $DLFILE = /* ]]; then
		if [ -f "$DLFILE" ]; then
		    echo "Using cached image $DLFILE for $ZISOFILE"
		    ZISOFILE="$DLFILE"
		else
		    echo "Downloading $ZISOFILE"
		    DLFILE=$(${ZAPLIBDIR}/retrieve-image $ZISOFILE)
		    if [ -f "$DLFILE" ]; then
			echo "Using downloaded image $DLFILE for $ZISOFILE"
			ZISOFILE="$DLFILE"
		    fi
		fi
	    fi
	fi
	if [[ $ZISOFILE != /* ]]; then
	    echo "ERROR: image name must be absolute or specify a valid download"
	    usage
	fi
	if [ ! -f $ZISOFILE ]; then
	    echo "ERROR: specified image not found"
	    usage
	fi
	;;
SUNWsolaris10)
	if [[ $ZISOFILE != /* ]]; then
	    echo "ERROR: image name must be absolute or specify a valid download"
	    usage
	fi
	if [ ! -f $ZISOFILE ]; then
	    echo "ERROR: specified image not found"
	    usage
	fi
	;;
bhyve)
	# require an image if we're not passed a prefilled volume
	if [[ -n $ZISOFILE ]]; then
	    if [[ $ZISOFILE != /* ]]; then
		#
		# check validity of the name
		#
		DLFILE=$(${ZAPLIBDIR}/retrieve-image -n $ZISOFILE)
		if [[ $DLFILE = /* ]]; then
		    if [ -f $DLFILE ]; then
			echo "Using cached image $DLFILE for $ZISOFILE"
			ZISOFILE="$DLFILE"
		    else
			echo "Downloading $ZISOFILE"
			DLFILE=$(${ZAPLIBDIR}/retrieve-image $ZISOFILE)
			if [ -f $DLFILE ]; then
			    echo "Using downloaded image $DLFILE for $ZISOFILE"
			    ZISOFILE="$DLFILE"
			fi
		    fi
		fi
	    fi
	    if [[ $ZISOFILE != /* ]]; then
		echo "ERROR: image name must be absolute or specify a valid download"
		usage
	    fi
	    if [[ $ZISOFILE != *.iso ]]; then
		echo "ERROR: bhyve requires an iso image"
		usage
	    fi
	    if [ ! -f $ZISOFILE ]; then
		echo "ERROR: specified image not found"
		usage
	    fi
	fi
	;;
esac

#
# construct a zone configuration file
#

#
# we overload ZBRAND with the template; the actual brand is
# specified in the template, and note that create -t actually
# refers to a template. Verify that the template and the file
# systems it uses exist.
#
if [[ -n $ZTEMPLATE ]]; then
    ZBRAND=TRIBtemplate-${ZTEMPLATE}
    if [ ! -f "/etc/zones/${ZBRAND}.xml" ]; then
	echo "ERROR: no such template ${ZTEMPLATE}"
	exit 1
    fi
    UDIR=$(/usr/bin/grep 'directory=\"/usr\"' /etc/zones/${ZBRAND}.xml | /usr/bin/awk '{print $2}' | /usr/bin/awk -F= '{print $2}' | /usr/bin/sed 's:"::g')
    if [ ! -d "${UDIR}" ]; then
	echo "ERROR: unable to find file systems for template ${ZTEMPLATE}"
	exit 1
    fi
fi

get_mask() {
CIDR=0
for octet in $(echo $1 | /usr/bin/sed 's:\.: :g')
do
case $octet in
255)
	CIDR=$(($CIDR+8)) ;;
254)
	CIDR=$(($CIDR+7)) ; break ;;
252)
	CIDR=$(($CIDR+6)) ; break ;;
248)
	CIDR=$(($CIDR+5)) ; break ;;
240)
	CIDR=$(($CIDR+4)) ; break ;;
224)
	CIDR=$(($CIDR+3)) ; break ;;
192)
	CIDR=$(($CIDR+2)) ; break ;;
128)
	CIDR=$(($CIDR+1)) ; break ;;
*)
	;;
esac
done
echo $CIDR
}

#
# return interface and cidr prefix for the given address
#
get_net_details() {
    IIP=$1
    NIP=$(get_short_net ${IIP}/24)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	IFACE=$(/usr/bin/grep interface: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}')
	ICIDR=24
	echo "$IFACE $ICIDR"
	return
    fi
    NIP=$(get_short_net ${IIP}/16)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	IFACE=$(/usr/bin/grep interface: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}')
	ICIDR=16
	echo "$IFACE $ICIDR"
	return
    fi
    NIP=$(get_short_net ${IIP}/8)
    if [ -f "${ZSDIR}/rconfig.${NIP}" ] ; then
	IFACE=$(/usr/bin/grep interface: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}')
	ICIDR=8
	echo "$IFACE $ICIDR"
	return
    fi
    IFACE=$(/usr/sbin/route -n get $IIP | /usr/bin/grep interface: | /usr/bin/awk '{print $NF}')
    IMASK=$(/usr/sbin/route -n get $IIP | /usr/bin/grep mask: | /usr/bin/awk '{print $NF}')
    ICIDR=$(get_mask $IMASK)
    echo "$IFACE $ICIDR"
}

#
# return the parent zone if routed
#
get_parent_zone() {
    IIP=$1
    NIP=$(get_short_net ${IIP}/24)
    if [ -f ${ZSDIR}/rconfig.${NIP} ] ; then
	/usr/bin/grep zone: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net ${IIP}/16)
    if [ -f ${ZSDIR}/rconfig.${NIP} ] ; then
	/usr/bin/grep zone: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net ${IIP}/8)
    if [ -f ${ZSDIR}/rconfig.${NIP} ] ; then
        /usr/bin/grep zone: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}'
	return
    fi
}

#
# return the default gateway for the given address
#
get_gateway() {
    IIP=$1
    NIP=$(get_short_net ${IIP}/24)
    if [ -f ${ZSDIR}/rconfig.${NIP} ] ; then
	/usr/bin/grep gateway: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net ${IIP}/16)
    if [ -f ${ZSDIR}/rconfig.${NIP} ] ; then
	/usr/bin/grep gateway: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}'
	return
    fi
    NIP=$(get_short_net ${IIP}/8)
    if [ -f ${ZSDIR}/rconfig.${NIP} ] ; then
        /usr/bin/grep gateway: ${ZSDIR}/rconfig.${NIP} | /usr/bin/awk '{print $NF}'
	return
    fi
    /usr/sbin/route -n get default | /usr/bin/grep gateway: | /usr/bin/awk '{print $NF}'
}

#
# return the short form of the network address - just the significant octets
# we only support /8 /16 /24 for router/proxy zones so no need to check
#
get_short_net() {
    IIP=$1
    SRPREFIX=${IIP##*/}
    SRSUBNET=${IIP%/*}
    echo $SRSUBNET | tr '.' ' '|read OCT1 OCT2 OCT3 OCT4
    case $SRPREFIX in
	8)
	    echo "${OCT1}"
	    ;;
	16)
	    echo "${OCT1}.${OCT2}"
	    ;;
	24)
	    echo "${OCT1}.${OCT2}.${OCT3}"
	    ;;
    esac
}

#
# create a link-local IPv6 address for the given IPv4 address
# the way we do this is simply to convert the IPv4 address to
# hex format, this guarantees we're unique if the IPv4 address
# is unique and won't conflict with regular addresses that are
# constructed from the mac address of the interface
#
# this is only used for shared-ip stacks; exclusive-ip stacks
# use the normal mechanism based on the mac address of the vnic
#
get_link_local() {
    IIP=$1
    printf "fe80::%x%x:%x%x/10" ${IIP//./ }
}

#
# this variant is for exclusive-ip, we get the mac address of the
# vnic and construct the address based on that
#
# the complex part here is that we need to flip bit 7
# also canonical format suppresses leading zeros
#
get_mac_link_local() {
    VNIC=$1
    /usr/sbin/dladm show-vnic -p -o MACADDRESS "$VNIC" | /usr/bin/sed 's=:= =g' | read o1 o2 o3 o4 o5 o6
    integer -i2 vi=16#$o1
    integer -i2 nvi
    nvi=$(($vi ^ 2#00000010))
    integer -i16 xv=$nvi
    no1=${xv/16#/}
    if [ "$no1" = "0" ]; then
	no1=""
    fi
    if [ "$no3" = "0" ]; then
	no3=""
    fi
    if [ "$no5" = "0" ]; then
	no5=""
    fi
    printf "fe80::%s%s:%sff:fe%s:%s%s/10" "$no1" "$o2" "$o3" "$o4" "$o5" "$o6"
}

create_configuration() {
if [ ! -d "$ZSDIR" ]; then
    /usr/bin/mkdir -p "$ZSDIR"
fi
touch "${ZSDIR}/zconfig.${ZNAME}"
if [ ! -f "${ZSDIR}/destroy.${ZNAME}" ]; then
    echo "#!/bin/sh" > "${ZSDIR}/destroy.${ZNAME}"
    /usr/bin/chmod a+x "${ZSDIR}/destroy.${ZNAME}"
fi
echo "/bin/rm -f ${ZSDIR}/zconfig.${ZNAME}" >> "${ZSDIR}/destroy.${ZNAME}"
echo "brand: $ZBRAND" >> "${ZSDIR}/zconfig.${ZNAME}"
echo "zone: $ZNAME" >> "${ZSDIR}/zconfig.${ZNAME}"
if [[ $ZBRAND = bhyve ]]; then
    echo create -b
    echo set brand=bhyve
else
    echo create -t $ZBRAND
fi
echo set autoboot=true
echo set zonepath=${ZROOTBASE}/${ZNAME}
if [[ -n $XIP4 ]]; then
    echo set ip-type=exclusive
    echo "ip-type: exclusive" >> "${ZSDIR}/zconfig.${ZNAME}"
else
    echo "ip-type: shared" >> "${ZSDIR}/zconfig.${ZNAME}"
fi
#
# shared ip addresses
#
for IP in $ZIP4
do
	echo "address: $IP" >> "${ZSDIR}/zconfig.${ZNAME}"
	get_net_details $IP | read ZIFACE ZCIDR
	echo add net
	echo set physical=$ZIFACE
	echo set address=${IP}/${ZCIDR}
	echo end
	if [[ -n $DOIP6 ]]; then
	    echo add net
	    echo set physical=$ZIFACE
	    echo set address=$(get_link_local $IP)
	    echo end
	fi
done
#
# exclusive-ip addresses
# the address is used to construct the topology, it's up to the
# zone to manage it, but we set up a valid hostname file later
#
# we also set the allowed-address property to restrict the zone
# (only for pure ipv4, as ipv6 doesn't seem to work properly)
#
# we set up the vnic here, and save details so that we can remove it
# when the zone is destroyed
#
ZENUM=0
for IP in $XIP4
do
	echo "address: $IP" >> "${ZSDIR}/zconfig.${ZNAME}"
	get_net_details $IP | read ZIFACE ZCIDR
	/usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	ZESTATUS=$?
	while [ $ZESTATUS -eq 0 ]
	do
	    ZENUM=$(($ZENUM+1))
	    /usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	    ZESTATUS=$?
	done
	/usr/sbin/dladm create-vnic -l "$ZIFACE" "znic$ZENUM"
	# if flow-properties are specified, create a flow here
	if [[ -n $FLOWPROPS ]]; then
	    /usr/sbin/flowadm add-flow -l "znic$ZENUM" -a local_ip=$IP -p $FLOWPROPS "znic${ZENUM}flow"
	    # don't be cute, remove all flows associated with this vnic
	    echo "/usr/sbin/flowadm remove-flow -l znic$ZENUM" >> "${ZSDIR}/destroy.${ZNAME}"
	fi
	# the vnic can only be deleted after the flow has been removed
	echo "/usr/sbin/dladm delete-vnic znic$ZENUM" >> "${ZSDIR}/destroy.${ZNAME}"
	ifipmap[znic$ZENUM]=$IP/$ZCIDR
	xifipmap[znic$ZENUM]=$IP/$ZCIDR
	echo add net
	echo set physical=znic$ZENUM
	#
	# we can't use allowed-address with IPv6, see below
	# we can't use allowed-address for a router zone, as the anti-spoofing
	# protection it brings prohibits IP forwarding and NAT
	#
	if [[ -z $DOIP6 && -z $RIP4 ]]; then
	    echo set allowed-address=$IP/$ZCIDR
	    # defrouter populates the gateway4 value in cloud-init
	    ZGW=$(get_gateway $XIP4)
	    if [[ -n $ZGW ]]; then
		echo set defrouter=$ZGW
	    fi
	fi
	echo end
	# in S11 allowed-address can be a list, but in illumos
	# you need to use multiple net blocks
	# this doesn't seem to work, the IPv6 address isn't brought up
	# if allowed-address is specified
	#if [[ -n $DOIP6 ]]; then
	#    echo add net
	#    echo set physical=znic$ZENUM
	#    echo set allowed-address=$(get_mac_link_local znic$ZENUM)
	#    echo end
	#fi
	ZROUTER=$(get_parent_zone $IP)
	if [[ -n $ZROUTER ]]; then
	    echo "parent_zone: $ZROUTER" >> "${ZSDIR}/zconfig.${ZNAME}"
	fi
done
#
# For router/proxy zones we create an etherstub for the internal virtual
# network, and create a vnic over that etherstub. The router/proxy zone
# will have the matching .1 address on that network.
#
# Note that the destroy script must have been initialized above as we
# require a router/proxy zone to have an exclusive-ip address, and we
# carry on enumerating ZENUM where we left off
#
ZRNUM=0
ZENUM=$(($ZENUM+1))
for IP in $RIP4
do
	/usr/sbin/dladm show-etherstub "zrstub$ZRNUM" > /dev/null 2>&1
	ZRSTATUS=$?
	while [ $ZRSTATUS -eq 0 ]
	do
	    ZRNUM=$(($ZRNUM+1))
	    /usr/sbin/dladm show-etherstub "zrstub$ZRNUM" > /dev/null 2>&1
	    ZRSTATUS=$?
	done
	ZIFACE=zrstub$ZRNUM
	/usr/sbin/dladm create-etherstub "$ZIFACE"
	/usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	ZESTATUS=$?
	while [ $ZESTATUS -eq 0 ]
	do
	    ZENUM=$(($ZENUM+1))
	    /usr/sbin/dladm show-vnic "znic$ZENUM" > /dev/null 2>&1
	    ZESTATUS=$?
	done
	/usr/sbin/dladm create-vnic -l "$ZIFACE" "znic$ZENUM"
	echo "/usr/sbin/dladm delete-vnic znic$ZENUM" >> "${ZSDIR}/destroy.${ZNAME}"
	# delete the etherstub after the vnic configured on it
	echo "/usr/sbin/dladm delete-etherstub $ZIFACE" >> "${ZSDIR}/destroy.${ZNAME}"
	ifipmap[znic$ZENUM]=$IP
	echo add net
	echo set physical=znic$ZENUM
	echo end
	# save the configuration here
	ZNETNAME=$(get_short_net $IP)
	touch "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "interface: $ZIFACE" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "gateway: ${IP%/*}" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "zone: ${ZNAME}" >> "${ZSDIR}/rconfig.${ZNETNAME}"
	echo "rm ${ZSDIR}/rconfig.${ZNETNAME}" >> "${ZSDIR}/destroy.${ZNAME}"
done
#
# for Tribblix-style zones, mount the zap package cache read-only in the
# zone where zap knows to look for it
#
if [[ $ZBRAND = TRIBsparse || $ZBRAND = TRIBwhole ]]; then
	if [ ! -d /var/zap/cache ]; then
	    /usr/bin/mkdir -p /var/zap/cache
	fi
	echo add fs
	echo set dir=/var/zap/global-cache
	echo set special=/var/zap/cache
	echo set type=lofs
	echo add options [ro,nodevices]
	echo end
fi
for DSET in $ZDATASETS
do
	echo add dataset
	echo set name=${DSET}
	echo end
done
for DIR in $ZDIRS
do
	/usr/bin/mkdir -p "${ZFSBASE}/${ZNAME}${DIR}"
	echo add fs
	echo set dir=${DIR}
	echo set special=${ZFSBASE}/${ZNAME}${DIR}
	echo set type=lofs
	echo add options [nodevices]
	echo end
done
for DIR in $ZSHARED
do
	echo add fs
	echo set dir=${DIR}
	echo set special=${DIR}
	echo set type=lofs
	echo add options [nodevices]
	echo end
done
for DIR in $ZROSHARED
do
	echo add fs
	echo set dir=${DIR}
	echo set special=${DIR}
	echo set type=lofs
	echo add options [ro,nodevices]
	echo end
done
for TUSER in $ZUSERS
do
	echo add fs
	DIR=$(/usr/bin/grep "^${TUSER}:" /etc/passwd | /usr/bin/awk -F: '{print $6}')
	echo set dir=${DIR}
	echo set special=${DIR}
	echo set type=lofs
	echo add options [nodevices]
	echo end
	echo add admin
	echo set user=${TUSER}
	echo set auths=manage
	echo end
done
#
# for lx, need to set the kernel version; ideally this would match the
# lx image installed, but the requirement is quite loose (as is shown
# by the fact that Docker works at all), so choose a reasonably modern
# default
#
if [[ $ZBRAND = SUNWlx ]]; then
	echo add attr
	echo set name=kernel-version
	echo set type=string
	echo set value=4.4.15
	echo end
fi
#
# memory and cpu settings, for bhyve these are passed as string attributes
# for other zone types we specify the capped-xxx resource controls
#
if [[ $ZBRAND != bhyve ]]; then
    if [[ -n $RAMSPEC ]]; then
	echo add capped-memory
	echo set physical=$RAMSPEC
	echo end
    fi
    if [[ -n $CPUSPEC ]]; then
	echo add capped-cpu
	echo set ncpus=$CPUSPEC
	echo end
    fi
fi
#
# for bhyve, there's a list of attributes we need
#
# the initial disk must be called "bootdisk", then the remainder
# are called "diskN", where N must start from zero
#
# note that we loop over $BHYVEVOLS and $BHYVEVOL, only one will
# be set
#
if [[ $ZBRAND = bhyve ]]; then
    VOLNUM=0
    VOLSTR="bootdisk"
    for BHVOL in $BHYVEVOLS $BHYVEVOL
    do
	echo add device
	echo set match=/dev/zvol/rdsk/${BHVOL}
	echo end
	echo add attr
	echo set name=${VOLSTR}
	echo set type=string
	echo set value=${BHVOL}
	echo end
	VOLSTR=disk${VOLNUM}
	VOLNUM=$(($VOLNUM+1))
    done
    if [[ -n $ZISOFILE ]]; then
	echo add fs
	echo set dir=${ZISOFILE}
	echo set special=${ZISOFILE}
	echo set type=lofs
	echo add options ro
	echo add options nodevices
	echo end
	echo add attr
	echo set name=cdrom
	echo set type=string
	echo set value=${ZISOFILE}
	echo end
    fi
    echo add attr
    echo set name=vnc
    echo set type=string
    echo set value=on
    echo end
    echo add attr
    echo set name=bootrom
    echo set type=string
    echo set value=${BHYVEFW}
    echo end
    echo add attr
    echo set name=acpi
    echo set type=string
    echo set value=off
    echo end
    case $ZISOFILE in
	*omnios*|*tribblix*|*hipster*|XStream*)
    echo add attr
    echo set name=xhci
    echo set type=string
    echo set value=off
    echo end
	;;
    esac
    case $ZISOFILE in
	*S11-CBE*)
    echo add attr
    echo set name=hostbridge
    echo set type=string
    echo set value=none
    echo end
    echo add attr
    echo set name=rng
    echo set type=string
    echo set value=off
    echo end
    echo add attr
    echo set name=type
    echo set type=string
    echo set value=windows
    echo end
    echo add attr
    echo set name=xhci
    echo set type=string
    echo set value=off
    echo end
        ;;
    esac
    # share directories over virtfs
    # note that the fs configuration has already been done, here
    # we set the attributes for bhyve to pick them up
    # note that we set the tag to a standardised "bhyvefsN" rather than a
    # string derived from the shared name, so that's what you'll need to
    # mount in the guest, via eg
    # mount -t 9p -o trans=virtio,uname=root bhyvefs0 /mnt/foo
    VFSNUM=0
    for DIR in $ZSHARED
    do
	echo add attr
	echo set name=virtfs${VFSNUM}
	echo set type=string
	echo set value=bhyvefs${VFSNUM},${DIR}
	echo end
	VFSNUM=$(($VFSNUM+1))
    done
    for DIR in $ZROSHARED
    do
	echo add attr
	echo set name=virtfs${VFSNUM}
	echo set type=string
	echo set value=bhyvefs${VFSNUM},${DIR},ro
	echo end
	VFSNUM=$(($VFSNUM+1))
    done
    if [[ -n $RAMSPEC ]]; then
	echo add attr
	echo set name=ram
	echo set type=string
	echo set value=$RAMSPEC
	echo end
    fi
    if [[ -n $CPUSPEC ]]; then
	echo add attr
	echo set name=vcpus
	echo set type=string
	echo set value=$CPUSPEC
	echo end
    fi
    if [[ -n $CLOUDINIT ]]; then
	echo add attr
	echo set name=cloud-init
	echo set type=string
	echo set value=on
	echo end
	# try and get resolvers from resolv.conf
	if [ -f /etc/resolv.conf ]; then
	    RESOLVERS=$(grep nameserver /etc/resolv.conf | awk '{printf $2","}' | sed 's:,$::')
	    if [[ -n $RESOLVERS ]]; then
		echo add attr
		echo set name=resolvers
		echo set type=string
		echo set value=$RESOLVERS
		echo end
	    fi
	fi
	# the file specified here is copied later into the zone at the fixed
	# location we give here, as cloud-init runs in the zone context
	if [[ -n $SSHKEYFILE ]]; then
	    echo add attr
	    echo set name=sshkey
	    echo set type=string
	    echo set value=/sshkey.pub
	    echo end
	fi
    fi
fi
echo verify
echo commit
}

#
# for an s10 branded zone, create a sysidcfg file
# assumes we just have a single interface
#
create_sysidcfg() {
    echo system_locale=C
    echo terminal=xterms
    echo "network_interface=primary {"
    echo "  hostname=${ZNAME}"
    if [[ -n $XIP4 ]]; then
	echo "ip_address=${XIP4}"
	IMASK=$(/usr/sbin/route -n get $XIP4 | /usr/bin/grep mask: | /usr/bin/awk '{print $NF}')
	echo "netmask=$IMASK"
	ZGW=$(get_gateway $XIP4)
	echo "default_route=$ZGW"
	if [[ -n $DOIP6 ]]; then
	    echo protocol_ipv6=yes
	else
	    echo protocol_ipv6=no
	fi
    fi
    echo "}"
    echo security_policy=NONE
    # we manually configure dns, so don't let sysidcfg mess it up
    echo "name_service=NONE"
    echo nfs4_domain=dynamic
    echo timezone=${TZ:=UTC}
    echo "root_password=jhDYXBAnWJKr2"
}

create_install_opts() {
for OVL in $ZOVERLAY
do
	printf " -o $OVL"
done
for OVL in $ZADDOVERLAY
do
	printf " -O $OVL"
done
for APKG in $ZPACKAGE
do
	printf " -p $APKG"
done
for APKG in $ZADDPACKAGE
do
	printf " -P $APKG"
done
if [[ -n $ZISOFILE && $ZBRAND != bhyve ]]; then
    printf " $IMGFLAG $ZISOFILE"
fi
if [[ $ZBRAND = SUNWsolaris10 ]]; then
    printf " -u"
fi
}

#
# if we're creating multiple zones, do them in a loop here, and exit
#
if [[ -n $NZONES ]]; then
    #
    # the address given is the address of the first zone, subsequent
    # zones increment the address, so check the last one is in range
    # the assumption here is that we have a whole subnet
    #
    for NIP in $XIP4 $ZIP4
    do
	NBEGIN=${NIP##*.}
	#
	# we assume that we can't use .1 as it's normally the router
	#
	if [ $NBEGIN -le 1 ]; then
	    echo "ERROR: base address $NIP must be at least .2"
	    exit 1
	fi
	NMAX=$(($NBEGIN+$NZONES))
	#
	# the largest valid address is 254, as 255 is broadcast
	# but the first zone adds zero to the base so we're off by one
	#
	if [ $NMAX -gt 255 ]; then
	    echo "ERROR: that many zones won't fit after $NIP"
	    exit 1
	fi
    done
    #
    # zone names are constructed by adding a number from 1..NZONES
    # to the given name, IP addresses add 0..NZONES-1
    # hence we increment the counter in the middle
    #
    NTHIS=0
    while [ $NTHIS -lt $NZONES ]
    do
	NADDR=""
	for NIP in $XIP4
	do
	    NSUB=${NIP%.*}
	    NBEGIN=${NIP##*.}
	    NADDR="$NADDR -x ${NSUB}.$(($NBEGIN+$NTHIS))"
	done
	for NIP in $ZIP4
	do
	    NSUB=${NIP%.*}
	    NBEGIN=${NIP##*.}
	    NADDR="$NADDR -i ${NSUB}.$(($NBEGIN+$NTHIS))"
	done
	NTHIS=$(($NTHIS+1))
	NZNAME="${ZNAME}${NTHIS}"
	#
	# handle delegated datasets
	# the argument is interpreted as a prefix, with the zone name
	# (not just the zone number) tacked on, as the dataset names must be
	# unique
	#
	NDATASETS=""
	for DSET in $ZDATASETS
	do
	    NDATASETS="${NDATASETS} -D ${DSET}/${NZNAME}"
	done
	#
	# construct command for this host, with unique zone name and addresses
	#
	echo "Creating zone ${NZNAME}"
	zap create-zone -t "$ZBRAND" -z "${NZNAME}" $NADDR ${NDATASETS} $NCMDLINE
    done
    exit 0
fi

#
# create any missing zfs datasets
#
if [[ -n ${ZDIRS} ]]; then
   ZPARENT=${ZFSBASE%/*}
   ZDPARENT=$(/usr/sbin/zfs list -H ${ZPARENT} | /usr/bin/awk '{print $1}')
   ZREALNAME=$(echo $ZFSBASE | /usr/bin/sed s:${ZPARENT}:${ZDPARENT}:)
   if [[ ! -d "${ZFSBASE}" ]]; then
      /usr/sbin/zfs create "${ZREALNAME}"
   fi
   if [[ ! -d "${ZFSBASE}/${ZNAME}" ]]; then
      /usr/sbin/zfs create "${ZREALNAME}/${ZNAME}"
   fi
fi
if [[ ! -d "${ZROOTBASE}" ]]; then
   ZPARENT=${ZROOTBASE%/*}
   ZDPARENT=$(/usr/sbin/zfs list -H ${ZPARENT} | /usr/bin/awk '{print $1}')
   ZREALNAME=$(echo $ZROOTBASE | /usr/bin/sed s:${ZPARENT}:${ZDPARENT}:)
   /usr/sbin/zfs create "${ZREALNAME}"
fi
#
# this one is split, we create any missing intermediate datasets
# but the final dataset has an explicit mountpoint property
#
for DSET in $ZDATASETS
do
    ZPARENT=${DSET%/*}
    /usr/sbin/zfs create -p "${ZPARENT}"
    /usr/sbin/zfs create -o mountpoint=none "${DSET}"
done
#
# volumes for bhyve - create and set
#
# FIXME allow user to specify pool to use
#
if [[ $ZBRAND = bhyve ]]; then
    BHYVEPOOL=rpool
    if [[ -z $BHYVEVOL ]]; then
	if [[ -n $BHYVEVOLSIZES ]]; then
	    for BHYVEVOLSIZE in $BHYVEVOLSIZES
	    do
		VOLENUM=0
		BVOLNAME=${ZNAME}_bhvol${VOLENUM}
		/usr/sbin/zfs get type ${BHYVEPOOL}/${BVOLNAME} > /dev/null 2>&1
		ZESTATUS=$?
		while [ $ZESTATUS -eq 0 ]
		do
		    VOLENUM=$(($VOLENUM+1))
		    BVOLNAME=${ZNAME}_bhvol${VOLENUM}
		    /usr/sbin/zfs get type ${BHYVEPOOL}/${BVOLNAME} > /dev/null 2>&1
		    ZESTATUS=$?
		done
		/usr/sbin/zfs create -V $BHYVEVOLSIZE ${BHYVEPOOL}/${BVOLNAME}
		BHYVEVOLS="${BHYVEVOLS} ${BHYVEPOOL}/${BVOLNAME}"
		if [ ! -f "${ZSDIR}/destroy.${ZNAME}" ]; then
		    echo "#!/bin/sh" > "${ZSDIR}/destroy.${ZNAME}"
		    /usr/bin/chmod a+x "${ZSDIR}/destroy.${ZNAME}"
		fi
		echo "/usr/sbin/zfs destroy ${BHYVEPOOL}/${BVOLNAME}" >> "${ZSDIR}/destroy.${ZNAME}"
	    done
	else
	    echo "ERROR: bhyve volume logic error"
	    exit 1
	fi
    fi
fi

ZCFGFILE=/tmp/zap.zcfg.$(date '+%F-%T').$$
create_configuration > "${ZCFGFILE}"

/usr/sbin/zonecfg -z "${ZNAME}" -f "${ZCFGFILE}"

/usr/sbin/zoneadm -z "${ZNAME}" install $(create_install_opts)

#
# copy the shared user accounts specified into the zone
# and allow them the root role if it's a Solarish type of zone
#
for TUSER in $ZUSERS
do
    /usr/bin/grep "^${TUSER}:" /etc/passwd >> "${ZROOTBASE}/${ZNAME}/root/etc/passwd"
    /usr/bin/grep "^${TUSER}:" /etc/shadow >> "${ZROOTBASE}/${ZNAME}/root/etc/shadow"
    #
    # try to make sure the shared user's group exists in the zone too
    #
    TGID=$(/usr/bin/grep "^${TUSER}:" /etc/passwd | /usr/bin/awk -F: '{print $4}')
    if [[ -n $TGID ]]; then
	if ! /usr/xpg4/bin/grep -q ":${TGID}:" "${ZROOTBASE}/${ZNAME}/root/etc/group"
	then
	    /usr/bin/grep ":${TGID}:" /etc/group >> "${ZROOTBASE}/${ZNAME}/root/etc/group"
	fi
    fi
    if [[ $ZBRAND != SUNWlx ]]; then
	echo "${TUSER}::::roles=root" >> "${ZROOTBASE}/${ZNAME}/root/etc/user_attr"
    fi
done

#
# for exclusive-ip stacks:
#  create /etc/hostname.* files for each vnic we created
#  set the default route
#
if [[ $ZBRAND != SUNWlx ]]; then
    for index in "${!ifipmap[@]}"
    do
	echo "${ifipmap[$index]}" > "${ZROOTBASE}/${ZNAME}/root/etc/hostname.$index"
	if [[ -n $DOIP6 ]]; then
	    touch "${ZROOTBASE}/${ZNAME}/root/etc/hostname6.$index"
	fi
    done
    if [[ -n $XIP4 ]]; then
	ZGW=$(get_gateway $XIP4)
	echo $ZGW > "${ZROOTBASE}/${ZNAME}/root/etc/defaultrouter"
    fi
fi

#
# for router/proxy zones:
#  ensure ipfilter is installed in the global zone, so that the devices that
#  the zone ipfilter needs are created; note that we don't need ipfilter to
#  actually run in the global zone
#  configure nat for all subnets behind the router zone
#  enable ip forwarding on all interfaces in the zone
#
if [[ -n $RIP4 ]]; then
    if [ ! -f /var/sadm/pkg/TRIBnet-ipfilter/pkginfo ]; then
	echo "Installing ipfilter in the global zone"
	/usr/bin/zap install TRIBnet-ipfilter
	sleep 1
    fi
    touch "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    echo "#!/bin/sh" > "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    for index in "${!ifipmap[@]}"
    do
	echo "/usr/sbin/ipadm set-ifprop -t -p forwarding=on -m ipv4 $index" >> "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    done
    echo /usr/sbin/svcadm enable network/ipfilter >> "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    chmod a+x "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
    IFACE=$(echo "${!xifipmap[@]}"|awk '{print $1}')
    touch "${ZROOTBASE}/${ZNAME}/root/etc/ipf/ipnat.conf"
    for subnet in $ORIP4
    do
	echo "map $IFACE $subnet -> 0/32 portmap tcp/udp auto" >> "${ZROOTBASE}/${ZNAME}/root/etc/ipf/ipnat.conf"
	echo "map $IFACE $subnet -> 0/32" >> "${ZROOTBASE}/${ZNAME}/root/etc/ipf/ipnat.conf"
    done
fi

#
# for managed router zones only, set up dnsmasq as well
#
if [[ -n $ISROUTER ]]; then
    # dnsmasq.d is where specific host configuration will be placed
    echo "conf-dir=/etc/dnsmasq.d" > ${ZROOTBASE}/${ZNAME}/root/etc/dnsmasq.conf
    # a dhcp-range entry is required to enable the dhcp server
    # all configuration is static, we fix the IP addresses 
    for subnet in $ORIP4
    do
	echo "dhcp-range=${subnet%/*},static" >> ${ZROOTBASE}/${ZNAME}/root/etc/dnsmasq.conf
    done
    # Ensure it gets enabled on boot
    echo /usr/sbin/svcadm enable network/dnsmasq >> "${ZROOTBASE}/${ZNAME}/root/etc/rc2.d/S83router"
fi

#
# blank the zone if requested; init requires the smf entry to be present in
# inittab but doesn't check what it actually runs
#
if [[ -n ${ZBLANK} ]]; then
    if [ -f "${ZROOTBASE}/${ZNAME}/root/etc/inittab" ]; then
        /usr/bin/sed -i 's:/lib/svc/bin/svc.startd:/usr/bin/sleep Inf:' "${ZROOTBASE}/${ZNAME}/root/etc/inittab"
    fi
fi

#
# do some minimalist configuration of the zone
#
/usr/bin/cp /etc/resolv.conf "${ZROOTBASE}/${ZNAME}/root/etc"
if [[ $ZBRAND != SUNWlx && $ZBRAND != bhyve ]]; then
    /usr/bin/cp /etc/default/init "${ZROOTBASE}/${ZNAME}/root/etc/default/init"
fi

#
# populate a sysidcfg file if we're an s10 branded zone
# sysidcfg resets nsswitch to none, so thwart that
# Copy in more minimal profile and .login to avoid
# attempts to run quota at login (which will likely not work)
#
if [[ $ZBRAND = SUNWsolaris10 ]]; then
    SYSIDCFGFILE=/tmp/zap.sysidcfg.${ZNAME}.$(date '+%F-%T').$$
    create_sysidcfg > "${SYSIDCFGFILE}"
    /usr/bin/cp "${SYSIDCFGFILE}" "${ZROOTBASE}/${ZNAME}/root/etc/sysidcfg"
    /usr/bin/cp "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.dns" "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.files"
    /usr/bin/cp "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.dns" "${ZROOTBASE}/${ZNAME}/root/etc/nsswitch.conf"
    /usr/bin/cp /etc/.login "${ZROOTBASE}/${ZNAME}/root/etc/.login"
    /usr/bin/cp /etc/profile "${ZROOTBASE}/${ZNAME}/root/etc/profile"
fi

#
# copy an ssh key to wherever the zone might expect it
#
if [[ -n "$SSHKEYFILE" ]]; then
    if [[ $ZBRAND = bhyve ]]; then
	# the /sshkey.pub name here must match the zone attribute
	/usr/bin/cp "$SSHKEYFILE" "${ZROOTBASE}/${ZNAME}/root/sshkey.pub"
    fi
    if [[ $ZBRAND = TRIBwhole || $ZBRAND = TRIBsparse || $ZBRAND = TRIBalien ]]; then
	# assume all illumos-type zones have the same directory structure
	UHOME=$(/usr/bin/awk -F: '{if ($1 == "root") print $6}' ${ZROOTBASE}/${ZNAME}/root/etc/passwd)
	if [ -n "$UHOME" ]; then
	    /usr/bin/mkdir -p -m 700 "${ZROOTBASE}/${ZNAME}/root/${UHOME}/.ssh"
	    /usr/bin/cp "$SSHKEYFILE" "${ZROOTBASE}/${ZNAME}/root/${UHOME}/.ssh/authorized_keys"
	    /usr/bin/chmod 600 "${ZROOTBASE}/${ZNAME}/root/${UHOME}/.ssh/authorized_keys"
	    /usr/bin/sed -i 's:^PermitRootLogin.*:PermitRootLogin without-password:' "${ZROOTBASE}/${ZNAME}/root/etc/ssh/sshd_config"
	fi
    fi
fi

#
# apply any konfiguration requests
#
for KARG in $KARGS
do
    ${ZAPLIBDIR}/zone-konfigurator -z "${ZNAME}" $KARG
done

/usr/sbin/zoneadm -z "${ZNAME}" boot
/usr/bin/rm "$ZCFGFILE"

if [[ -n ${SYSIDCFGFILE} ]]; then
    /usr/bin/rm -f "$SYSIDCFGFILE"
fi
